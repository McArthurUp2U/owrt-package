From cc08d2c9ff41eaf1f78ec7383c78b2ab03a46115 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Tue, 28 Jan 2014 23:18:23 +0100
Subject: [PATCH 81/82] MEDIUM: counters: stop relying on session flags at all

Till now, we had one flag per stick counter to indicate if it was
tracked in a backend or in a frontend. We just had to add another
flag per stick-counter to indicate if it relies on contents or just
connection. These flags are quite painful to maintain and tend to
easily conflict with other flags if their number is changed.

The correct solution consists in moving the flags to the stkctr struct
itself, but currently this struct is made of 2 pointers, so adding a
new entry there to store only two bits will cause at least 16 more bytes
to be eaten per counter due to alignment issues, and we definitely don't
want to waste tens to hundreds of bytes per session just for things that
most users don't use.

Since we only need to store two bits per counter, an intermediate
solution consists in replacing the entry pointer with a composite
value made of the original entry pointer and the two flags in the
2 unused lower bits. If later a need for other flags arises, we'll
have to store them in the struct.

A few inline functions have been added to abstract the retrieval
and assignment of the pointers and flags, resulting in very few
changes. That way there is no more dependence on the number of
stick-counters and their position in the session flags.
---
 include/common/defaults.h |  2 -
 include/proto/session.h   | 83 ++++++++++++++++++++++++---------------
 include/types/session.h   | 22 +++--------
 src/proto_tcp.c           |  8 ++--
 src/session.c             | 98 +++++++++++++++++++++++------------------------
 5 files changed, 112 insertions(+), 101 deletions(-)

diff --git a/include/common/defaults.h b/include/common/defaults.h
index 856e281..f765e90 100644
--- a/include/common/defaults.h
+++ b/include/common/defaults.h
@@ -75,8 +75,6 @@
 #endif
 
 // max # of stick counters per session (at least 3 for sc0..sc2)
-// Some changes are needed in TCP_ACT_TRK_SC*, SN_BE_TRACK_SC*, and
-// SN_CT_TRACK_SC* if more values are required.
 #ifndef MAX_SESS_STKCTR
 #define MAX_SESS_STKCTR 3
 #endif
diff --git a/include/proto/session.h b/include/proto/session.h
index 3736845..fc83989 100644
--- a/include/proto/session.h
+++ b/include/proto/session.h
@@ -56,6 +56,36 @@ static inline struct session *session_from_task(struct task *t)
 	return (struct session *)t->context;
 }
 
+/* sets the stick counter's entry pointer */
+static inline void stkctr_set_entry(struct stkctr *stkctr, struct stksess *entry)
+{
+	stkctr->entry = caddr_from_ptr(entry, 0);
+}
+
+/* returns the entry pointer from a stick counter */
+static inline struct stksess *stkctr_entry(struct stkctr *stkctr)
+{
+	return caddr_to_ptr(stkctr->entry);
+}
+
+/* returns the two flags from a stick counter */
+static inline unsigned int stkctr_flags(struct stkctr *stkctr)
+{
+	return caddr_to_data(stkctr->entry);
+}
+
+/* sets up to two flags at a time on a composite address */
+static inline void stkctr_set_flags(struct stkctr *stkctr, unsigned int flags)
+{
+	stkctr->entry = caddr_set_flags(stkctr->entry, flags);
+}
+
+/* returns the two flags from a stick counter */
+static inline void stkctr_clr_flags(struct stkctr *stkctr, unsigned int flags)
+{
+	stkctr->entry = caddr_clr_flags(stkctr->entry, flags);
+}
+
 /* Remove the refcount from the session to the tracked counters, and clear the
  * pointer to ensure this is only performed once. The caller is responsible for
  * ensuring that the pointer is valid first.
@@ -66,14 +96,14 @@ static inline void session_store_counters(struct session *s)
 	int i;
 
 	for (i = 0; i < MAX_SESS_STKCTR; i++) {
-		if (!s->stkctr[i].entry)
+		if (!stkctr_entry(&s->stkctr[i]))
 			continue;
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_CONN_CUR);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_CONN_CUR);
 		if (ptr)
 			stktable_data_cast(ptr, conn_cur)--;
-		s->stkctr[i].entry->ref_cnt--;
-		stksess_kill_if_expired(s->stkctr[i].table, s->stkctr[i].entry);
-		s->stkctr[i].entry = NULL;
+		stkctr_entry(&s->stkctr[i])->ref_cnt--;
+		stksess_kill_if_expired(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]));
+		stkctr_set_entry(&s->stkctr[i], NULL);
 	}
 }
 
@@ -86,24 +116,20 @@ static inline void session_stop_content_counters(struct session *s)
 	void *ptr;
 	int i;
 
-	if (likely(!(s->flags & SN_CT_TRACK_ANY)))
-		return;
-
 	for (i = 0; i < MAX_SESS_STKCTR; i++) {
-		if (!s->stkctr[i].entry)
+		if (!stkctr_entry(&s->stkctr[i]))
 			continue;
 
-		if (!(s->flags & (SN_CT_TRACK_SC0 << i)))
+		if (!(stkctr_flags(&s->stkctr[i]) & STKCTR_TRACK_CONTENT))
 			continue;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_CONN_CUR);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_CONN_CUR);
 		if (ptr)
 			stktable_data_cast(ptr, conn_cur)--;
-		s->stkctr[i].entry->ref_cnt--;
-		stksess_kill_if_expired(s->stkctr[i].table, s->stkctr[i].entry);
-		s->stkctr[i].entry = NULL;
+		stkctr_entry(&s->stkctr[i])->ref_cnt--;
+		stksess_kill_if_expired(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]));
+		stkctr_set_entry(&s->stkctr[i], NULL);
 	}
-	s->flags &= ~SN_CT_TRACK_ANY;
 }
 
 /* Increase total and concurrent connection count for stick entry <ts> of table
@@ -136,12 +162,12 @@ static inline void session_start_counters(struct stktable *t, struct stksess *ts
  */
 static inline void session_track_stkctr(struct stkctr *ctr, struct stktable *t, struct stksess *ts)
 {
-	if (ctr->entry)
+	if (stkctr_entry(ctr))
 		return;
 
 	ts->ref_cnt++;
 	ctr->table = t;
-	ctr->entry = ts;
+	stkctr_set_entry(ctr, ts);
 	session_start_counters(t, ts);
 }
 
@@ -152,14 +178,14 @@ static void inline session_inc_http_req_ctr(struct session *s)
 	int i;
 
 	for (i = 0; i < MAX_SESS_STKCTR; i++) {
-		if (!s->stkctr[i].entry)
+		if (!stkctr_entry(&s->stkctr[i]))
 			continue;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_HTTP_REQ_CNT);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_HTTP_REQ_CNT);
 		if (ptr)
 			stktable_data_cast(ptr, http_req_cnt)++;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_HTTP_REQ_RATE);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_HTTP_REQ_RATE);
 		if (ptr)
 			update_freq_ctr_period(&stktable_data_cast(ptr, http_req_rate),
 					       s->stkctr[i].table->data_arg[STKTABLE_DT_HTTP_REQ_RATE].u, 1);
@@ -172,21 +198,18 @@ static void inline session_inc_be_http_req_ctr(struct session *s)
 	void *ptr;
 	int i;
 
-	if (likely(!(s->flags & SN_BE_TRACK_ANY)))
-		return;
-
 	for (i = 0; i < MAX_SESS_STKCTR; i++) {
-		if (!s->stkctr[i].entry)
+		if (!stkctr_entry(&s->stkctr[i]))
 			continue;
 
-		if (!(s->flags & (SN_BE_TRACK_SC0 << i)))
+		if (!(stkctr_flags(&s->stkctr[i]) & STKCTR_TRACK_BACKEND))
 			continue;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_HTTP_REQ_CNT);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_HTTP_REQ_CNT);
 		if (ptr)
 			stktable_data_cast(ptr, http_req_cnt)++;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_HTTP_REQ_RATE);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_HTTP_REQ_RATE);
 		if (ptr)
 			update_freq_ctr_period(&stktable_data_cast(ptr, http_req_rate),
 			                       s->stkctr[i].table->data_arg[STKTABLE_DT_HTTP_REQ_RATE].u, 1);
@@ -205,14 +228,14 @@ static void inline session_inc_http_err_ctr(struct session *s)
 	int i;
 
 	for (i = 0; i < MAX_SESS_STKCTR; i++) {
-		if (!s->stkctr[i].entry)
+		if (!stkctr_entry(&s->stkctr[i]))
 			continue;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_HTTP_ERR_CNT);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_HTTP_ERR_CNT);
 		if (ptr)
 			stktable_data_cast(ptr, http_err_cnt)++;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_HTTP_ERR_RATE);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_HTTP_ERR_RATE);
 		if (ptr)
 			update_freq_ctr_period(&stktable_data_cast(ptr, http_err_rate),
 			                       s->stkctr[i].table->data_arg[STKTABLE_DT_HTTP_ERR_RATE].u, 1);
diff --git a/include/types/session.h b/include/types/session.h
index add8c32..9b5a5bf 100644
--- a/include/types/session.h
+++ b/include/types/session.h
@@ -90,27 +90,17 @@
 
 #define SN_COMP_READY   0x00100000	/* the compression is initialized */
 
-/* session tracking flags: these ones must absolutely be contiguous and cover
- * at least MAX_SESS_STKCTR flags.
- */
-#define SN_BE_TRACK_SC0 0x00200000	/* backend tracks stick-counter 0 */
-#define SN_BE_TRACK_SC1 0x00400000	/* backend tracks stick-counter 1 */
-#define SN_BE_TRACK_SC2 0x00800000	/* backend tracks stick-counter 2 */
-#define SN_BE_TRACK_ANY 0x00E00000      /* union of all SN_BE_TRACK_* above */
-
-#define SN_CT_TRACK_SC0 0x01000000      /* stick-counter 0 tracked at the content level */
-#define SN_CT_TRACK_SC1 0x02000000      /* stick-counter 1 tracked at the content level */
-#define SN_CT_TRACK_SC2 0x04000000      /* stick-counter 2 tracked at the content level */
-#define SN_CT_TRACK_ANY 0x07000000      /* union of all SN_CT_TRACK_* above */
-
-
 /* WARNING: if new fields are added, they must be initialized in session_accept()
  * and freed in session_free() !
  */
 
-/* stick counter */
+#define STKCTR_TRACK_BACKEND 1
+#define STKCTR_TRACK_CONTENT 2
+/* stick counter. The <entry> member is a composite address (caddr) made of a
+ * pointer to an stksess struct, and two flags among STKCTR_TRACK_* above.
+ */
 struct stkctr {
-	struct stksess *entry;          /* entry containing counters currently being tracked  by this session */
+	unsigned long   entry;          /* entry containing counters currently being tracked by this session  */
 	struct stktable *table;         /* table the counters above belong to (undefined if counters are null) */
 };
 
diff --git a/src/proto_tcp.c b/src/proto_tcp.c
index 9baaff7..11f6331 100644
--- a/src/proto_tcp.c
+++ b/src/proto_tcp.c
@@ -1021,7 +1021,7 @@ int tcp_inspect_request(struct session *s, struct channel *req, int an_bit)
 				 */
 				struct stktable_key *key;
 
-				if (s->stkctr[tcp_trk_idx(rule->action)].entry)
+				if (stkctr_entry(&s->stkctr[tcp_trk_idx(rule->action)]))
 					continue;
 
 				t = rule->act_prm.trk_ctr.table.t;
@@ -1029,9 +1029,9 @@ int tcp_inspect_request(struct session *s, struct channel *req, int an_bit)
 
 				if (key && (ts = stktable_get_entry(t, key))) {
 					session_track_stkctr(&s->stkctr[tcp_trk_idx(rule->action)], t, ts);
-					s->flags |= SN_CT_TRACK_SC0 << tcp_trk_idx(rule->action);
+					stkctr_set_flags(&s->stkctr[tcp_trk_idx(rule->action)], STKCTR_TRACK_CONTENT);
 					if (s->fe != s->be)
-						s->flags |= SN_BE_TRACK_SC0 << tcp_trk_idx(rule->action);
+						stkctr_set_flags(&s->stkctr[tcp_trk_idx(rule->action)], STKCTR_TRACK_BACKEND);
 				}
 			}
 			else {
@@ -1188,7 +1188,7 @@ int tcp_exec_req_rules(struct session *s)
 				 */
 				struct stktable_key *key;
 
-				if (s->stkctr[tcp_trk_idx(rule->action)].entry)
+				if (stkctr_entry(&s->stkctr[tcp_trk_idx(rule->action)]))
 					continue;
 
 				t = rule->act_prm.trk_ctr.table.t;
diff --git a/src/session.c b/src/session.c
index 600d536..1faf0c3 100644
--- a/src/session.c
+++ b/src/session.c
@@ -435,14 +435,14 @@ int session_complete(struct session *s)
 	for (i = 0; i < MAX_SESS_STKCTR; i++) {
 		void *ptr;
 
-		if (!s->stkctr[i].entry)
+		if (!stkctr_entry(&s->stkctr[i]))
 			continue;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_SESS_CNT);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_SESS_CNT);
 		if (ptr)
 			stktable_data_cast(ptr, sess_cnt)++;
 
-		ptr = stktable_data_ptr(s->stkctr[i].table, s->stkctr[i].entry, STKTABLE_DT_SESS_RATE);
+		ptr = stktable_data_ptr(s->stkctr[i].table, stkctr_entry(&s->stkctr[i]), STKTABLE_DT_SESS_RATE);
 		if (ptr)
 			update_freq_ctr_period(&stktable_data_cast(ptr, sess_rate),
 					       s->stkctr[i].table->data_arg[STKTABLE_DT_SESS_RATE].u, 1);
@@ -707,17 +707,17 @@ void session_process_counters(struct session *s)
 				s->listener->counters->bytes_in += bytes;
 
 			for (i = 0; i < MAX_SESS_STKCTR; i++) {
-				if (!s->stkctr[i].entry)
+				if (!stkctr_entry(&s->stkctr[i]))
 					continue;
 
 				ptr = stktable_data_ptr(s->stkctr[i].table,
-				                        s->stkctr[i].entry,
+				                        stkctr_entry(&s->stkctr[i]),
 				                        STKTABLE_DT_BYTES_IN_CNT);
 				if (ptr)
 					stktable_data_cast(ptr, bytes_in_cnt) += bytes;
 
 				ptr = stktable_data_ptr(s->stkctr[i].table,
-				                        s->stkctr[i].entry,
+				                        stkctr_entry(&s->stkctr[i]),
 				                        STKTABLE_DT_BYTES_IN_RATE);
 				if (ptr)
 					update_freq_ctr_period(&stktable_data_cast(ptr, bytes_in_rate),
@@ -741,17 +741,17 @@ void session_process_counters(struct session *s)
 				s->listener->counters->bytes_out += bytes;
 
 			for (i = 0; i < MAX_SESS_STKCTR; i++) {
-				if (!s->stkctr[i].entry)
+				if (!stkctr_entry(&s->stkctr[i]))
 					continue;
 
 				ptr = stktable_data_ptr(s->stkctr[i].table,
-				                        s->stkctr[i].entry,
+				                        stkctr_entry(&s->stkctr[i]),
 				                        STKTABLE_DT_BYTES_OUT_CNT);
 				if (ptr)
 					stktable_data_cast(ptr, bytes_out_cnt) += bytes;
 
 				ptr = stktable_data_ptr(s->stkctr[i].table,
-				                        s->stkctr[i].entry,
+				                        stkctr_entry(&s->stkctr[i]),
 				                        STKTABLE_DT_BYTES_OUT_RATE);
 				if (ptr)
 					update_freq_ctr_period(&stktable_data_cast(ptr, bytes_out_rate),
@@ -2651,7 +2651,7 @@ smp_fetch_sc_stkctr(struct session *l4, const struct arg *args, const char *kw)
 			return NULL;
 
 		stkctr.table = &args->data.prx->table;
-		stkctr.entry = stktable_lookup_key(stkctr.table, key);
+		stkctr_set_entry(&stkctr, stktable_lookup_key(stkctr.table, key));
 		return &stkctr;
 	}
 
@@ -2662,10 +2662,10 @@ smp_fetch_sc_stkctr(struct session *l4, const struct arg *args, const char *kw)
 	if (unlikely(args[arg].type == ARGT_TAB)) {
 		/* an alternate table was specified, let's look up the same key there */
 		stkctr.table = &args[arg].data.prx->table;
-		stkctr.entry = stktable_lookup(stkctr.table, l4->stkctr[num].entry);
+		stkctr_set_entry(&stkctr, stktable_lookup(stkctr.table, stkctr_entry(&l4->stkctr[num])));
 		return &stkctr;
 	}
-	return l4->stkctr[num].entry ? &l4->stkctr[num] : NULL;
+	return stkctr_entry(&l4->stkctr[num]) ? &l4->stkctr[num] : NULL;
 }
 
 /* set return a boolean indicating if the requested session counter is
@@ -2678,7 +2678,7 @@ smp_fetch_sc_tracked(struct proxy *px, struct session *l4, void *l7, unsigned in
 {
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_BOOL;
-	smp->data.uint = !!l4->stkctr[kw[2] - '0'].entry;
+	smp->data.uint = !!stkctr_entry(&l4->stkctr[kw[2] - '0']);
 	return 1;
 }
 
@@ -2700,8 +2700,8 @@ smp_fetch_sc_get_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned i
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
 
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_GPC0);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_GPC0);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, gpc0);
@@ -2726,8 +2726,8 @@ smp_fetch_sc_gpc0_rate(struct proxy *px, struct session *l4, void *l7, unsigned
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_GPC0_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_GPC0_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, gpc0_rate),
@@ -2752,20 +2752,20 @@ smp_fetch_sc_inc_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned i
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
+	if (stkctr_entry(stkctr) != NULL) {
 		void *ptr;
 
 		/* First, update gpc0_rate if it's tracked. Second, update its
 		 * gpc0 if tracked. Returns gpc0's value otherwise the curr_ctr.
 		 */
-		ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_GPC0_RATE);
+		ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_GPC0_RATE);
 		if (ptr) {
 			update_freq_ctr_period(&stktable_data_cast(ptr, gpc0_rate),
 					       stkctr->table->data_arg[STKTABLE_DT_GPC0_RATE].u, 1);
 			smp->data.uint = (&stktable_data_cast(ptr, gpc0_rate))->curr_ctr;
 		}
 
-		ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_GPC0);
+		ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_GPC0);
 		if (ptr)
 			smp->data.uint = ++stktable_data_cast(ptr, gpc0);
 
@@ -2789,8 +2789,8 @@ smp_fetch_sc_clr_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned i
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_GPC0);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_GPC0);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, gpc0);
@@ -2815,8 +2815,8 @@ smp_fetch_sc_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned i
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_CONN_CNT);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_CONN_CNT);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, conn_cnt);
@@ -2840,8 +2840,8 @@ smp_fetch_sc_conn_rate(struct proxy *px, struct session *l4, void *l7, unsigned
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_CONN_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_CONN_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, conn_rate),
@@ -2902,8 +2902,8 @@ smp_fetch_sc_conn_cur(struct proxy *px, struct session *l4, void *l7, unsigned i
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_CONN_CUR);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_CONN_CUR);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, conn_cur);
@@ -2927,8 +2927,8 @@ smp_fetch_sc_sess_cnt(struct proxy *px, struct session *l4, void *l7, unsigned i
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_SESS_CNT);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_SESS_CNT);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, sess_cnt);
@@ -2951,8 +2951,8 @@ smp_fetch_sc_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_SESS_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_SESS_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, sess_rate),
@@ -2977,8 +2977,8 @@ smp_fetch_sc_http_req_cnt(struct proxy *px, struct session *l4, void *l7, unsign
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_HTTP_REQ_CNT);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_HTTP_REQ_CNT);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, http_req_cnt);
@@ -3002,8 +3002,8 @@ smp_fetch_sc_http_req_rate(struct proxy *px, struct session *l4, void *l7, unsig
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_HTTP_REQ_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_HTTP_REQ_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, http_req_rate),
@@ -3028,8 +3028,8 @@ smp_fetch_sc_http_err_cnt(struct proxy *px, struct session *l4, void *l7, unsign
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_HTTP_ERR_CNT);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_HTTP_ERR_CNT);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, http_err_cnt);
@@ -3053,8 +3053,8 @@ smp_fetch_sc_http_err_rate(struct proxy *px, struct session *l4, void *l7, unsig
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_HTTP_ERR_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_HTTP_ERR_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, http_err_rate),
@@ -3079,8 +3079,8 @@ smp_fetch_sc_kbytes_in(struct proxy *px, struct session *l4, void *l7, unsigned
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_BYTES_IN_CNT);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_BYTES_IN_CNT);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, bytes_in_cnt) >> 10;
@@ -3104,8 +3104,8 @@ smp_fetch_sc_bytes_in_rate(struct proxy *px, struct session *l4, void *l7, unsig
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_BYTES_IN_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_BYTES_IN_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, bytes_in_rate),
@@ -3130,8 +3130,8 @@ smp_fetch_sc_kbytes_out(struct proxy *px, struct session *l4, void *l7, unsigned
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_BYTES_OUT_CNT);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_BYTES_OUT_CNT);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = stktable_data_cast(ptr, bytes_out_cnt) >> 10;
@@ -3155,8 +3155,8 @@ smp_fetch_sc_bytes_out_rate(struct proxy *px, struct session *l4, void *l7, unsi
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
 	smp->data.uint = 0;
-	if (stkctr->entry != NULL) {
-		void *ptr = stktable_data_ptr(stkctr->table, stkctr->entry, STKTABLE_DT_BYTES_OUT_RATE);
+	if (stkctr_entry(stkctr) != NULL) {
+		void *ptr = stktable_data_ptr(stkctr->table, stkctr_entry(stkctr), STKTABLE_DT_BYTES_OUT_RATE);
 		if (!ptr)
 			return 0; /* parameter not stored */
 		smp->data.uint = read_freq_ctr_period(&stktable_data_cast(ptr, bytes_out_rate),
@@ -3179,7 +3179,7 @@ smp_fetch_sc_trackers(struct proxy *px, struct session *l4, void *l7, unsigned i
 
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_UINT;
-	smp->data.uint = stkctr->entry->ref_cnt;
+	smp->data.uint = stkctr_entry(stkctr)->ref_cnt;
 	return 1;
 }
 
-- 
1.8.3.2

