From 628c40cd961dc096549edc41ddd52f6d4b816c2a Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 24 Apr 2014 19:11:26 +0200
Subject: [PATCH 09/17] MEDIUM: http: move skipping of 100-continue earlier

It's useless to process 100-continue in the middle of response filters
because there's no info in the 100 response itself, and it could even
make things worse. So better use it as it is, an interim response
waiting for the next response, thus we just have to put it into
http_wait_for_response(). That way we ensure to have a valid response
in this function.
---
 src/proto_http.c | 33 ++++++++++++++++-----------------
 1 file changed, 16 insertions(+), 17 deletions(-)

diff --git a/src/proto_http.c b/src/proto_http.c
index 6ee9354..fc185be 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -5296,6 +5296,7 @@ int http_wait_for_response(struct session *s, struct channel *rep, int an_bit)
 	 *   msg->next          = first non-visited byte
 	 */
 
+ next_one:
 	/* There's a protected area at the end of the buffer for rewriting
 	 * purposes. We don't want to start to parse the request if the
 	 * protected area is affected, because we may have to move processed
@@ -5576,6 +5577,20 @@ int http_wait_for_response(struct session *s, struct channel *rep, int an_bit)
 	 */
 
 	switch (txn->status) {
+	case 100:
+		/*
+		 * We may be facing a 100-continue response, in which case this
+		 * is not the right response, and we're waiting for the next one.
+		 * Let's allow this response to go to the client and wait for the
+		 * next one.
+		 */
+		hdr_idx_init(&txn->hdr_idx);
+		msg->next -= channel_forward(rep, msg->next);
+		msg->msg_state = HTTP_MSG_RPBEFORE;
+		txn->status = 0;
+		s->logs.t_data = -1; /* was not a response yet */
+		goto next_one;
+
 	case 200:
 	case 203:
 	case 206:
@@ -5919,23 +5934,7 @@ int http_process_res_common(struct session *t, struct channel *rep, int an_bit,
 			cur_proxy = t->fe;
 		}
 
-		/*
-		 * We may be facing a 100-continue response, in which case this
-		 * is not the right response, and we're waiting for the next one.
-		 * Let's allow this response to go to the client and wait for the
-		 * next one.
-		 */
-		if (unlikely(txn->status == 100)) {
-			hdr_idx_init(&txn->hdr_idx);
-			msg->next -= channel_forward(rep, msg->next);
-			msg->msg_state = HTTP_MSG_RPBEFORE;
-			txn->status = 0;
-			t->logs.t_data = -1; /* was not a response yet */
-			rep->analysers |= AN_RES_WAIT_HTTP | an_bit;
-			rep->flags |= CF_WAKE_WRITE;
-			return 1;
-		}
-		else if (unlikely(txn->status < 200))
+		if (unlikely(txn->status < 200))
 			goto skip_header_mangling;
 
 		/* we don't have any 1xx status code now */
-- 
1.8.3.2

