From 16f649c82c8119d28d4b9e8c926772f20211c857 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Sat, 25 Jan 2014 19:10:48 +0100
Subject: [PATCH 54/69] REORG: polling: rename "fd_spec" to "fd_cache"

So fd_spec was renamed "fd_cache" as it's becoming an event cache, and
fd_nbspec becomes fd_cache_num.
---
 include/proto/fd.h | 22 +++++++++++-----------
 src/dumpstats.c    |  2 +-
 src/ev_epoll.c     |  2 +-
 src/ev_kqueue.c    |  2 +-
 src/ev_poll.c      |  2 +-
 src/ev_select.c    |  2 +-
 src/fd.c           | 25 ++++++++++++-------------
 7 files changed, 28 insertions(+), 29 deletions(-)

diff --git a/include/proto/fd.h b/include/proto/fd.h
index 3563a08..ba08260 100644
--- a/include/proto/fd.h
+++ b/include/proto/fd.h
@@ -31,10 +31,10 @@
 #include <types/fd.h>
 
 /* public variables */
-extern int fd_nbspec;          // number of speculative events in the list
-extern int fd_nbupdt;          // number of updates in the list
-extern unsigned int *fd_spec;  // speculative I/O list
-extern unsigned int *fd_updt;  // FD updates list
+extern unsigned int *fd_cache;      // FD events cache
+extern unsigned int *fd_updt;       // FD updates list
+extern int fd_cache_num;            // number of events in the cache
+extern int fd_nbupdt;               // number of updates in the list
 
 /* Deletes an FD from the fdsets, and recomputes the maxfd limit.
  * The file descriptor is also closed.
@@ -100,9 +100,9 @@ static inline void alloc_spec_entry(const int fd)
 	if (fdtab[fd].cache)
 		/* FD already in speculative I/O list */
 		return;
-	fd_nbspec++;
-	fdtab[fd].cache = fd_nbspec;
-	fd_spec[fd_nbspec-1] = fd;
+	fd_cache_num++;
+	fdtab[fd].cache = fd_cache_num;
+	fd_cache[fd_cache_num-1] = fd;
 }
 
 /* Removes entry used by fd <fd> from the spec list and replaces it with the
@@ -117,11 +117,11 @@ static inline void release_spec_entry(int fd)
 	if (!pos)
 		return;
 	fdtab[fd].cache = 0;
-	fd_nbspec--;
-	if (likely(pos <= fd_nbspec)) {
+	fd_cache_num--;
+	if (likely(pos <= fd_cache_num)) {
 		/* was not the last entry */
-		fd = fd_spec[fd_nbspec];
-		fd_spec[pos - 1] = fd;
+		fd = fd_cache[fd_cache_num];
+		fd_cache[pos - 1] = fd;
 		fdtab[fd].cache = pos;
 	}
 }
diff --git a/src/dumpstats.c b/src/dumpstats.c
index aabb556..19d4dbd 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -4525,7 +4525,7 @@ static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct se
 			              obj_base_ptr(conn->target));
 
 			chunk_appendf(&trash,
-			              "      flags=0x%08x fd=%d fd_spec_e=%02x fd_spec_p=%d updt=%d\n",
+			              "      flags=0x%08x fd=%d fd.state=%02x fd.cache=%d updt=%d\n",
 			              conn->flags,
 			              conn->t.sock.fd,
 			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].state : 0,
diff --git a/src/ev_epoll.c b/src/ev_epoll.c
index e826af3..45f7cea 100644
--- a/src/ev_epoll.c
+++ b/src/ev_epoll.c
@@ -111,7 +111,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 
 	/* compute the epoll_wait() timeout */
 
-	if (fd_nbspec || run_queue || signal_queue_len) {
+	if (fd_cache_num || run_queue || signal_queue_len) {
 		/* Maybe we still have events in the spec list, or there are
 		 * some tasks left pending in the run_queue, so we must not
 		 * wait in epoll() otherwise we would delay their delivery by
diff --git a/src/ev_kqueue.c b/src/ev_kqueue.c
index d59a570..3aa3fd1 100644
--- a/src/ev_kqueue.c
+++ b/src/ev_kqueue.c
@@ -104,7 +104,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	timeout.tv_sec  = 0;
 	timeout.tv_nsec = 0;
 
-	if (!fd_nbspec && !run_queue && !signal_queue_len) {
+	if (!fd_cache_num && !run_queue && !signal_queue_len) {
 		if (!exp) {
 			delta_ms        = MAX_DELAY_MS;
 			timeout.tv_sec  = (MAX_DELAY_MS / 1000);
diff --git a/src/ev_poll.c b/src/ev_poll.c
index 6a97c98..6d550a6 100644
--- a/src/ev_poll.c
+++ b/src/ev_poll.c
@@ -126,7 +126,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	}
       
 	/* now let's wait for events */
-	if (fd_nbspec || run_queue || signal_queue_len)
+	if (fd_cache_num || run_queue || signal_queue_len)
 		wait_time = 0;
 	else if (!exp)
 		wait_time = MAX_DELAY_MS;
diff --git a/src/ev_select.c b/src/ev_select.c
index 14f1b1e..f79cdbf 100644
--- a/src/ev_select.c
+++ b/src/ev_select.c
@@ -93,7 +93,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	delta.tv_sec  = 0;
 	delta.tv_usec = 0;
 
-	if (!fd_nbspec && !run_queue && !signal_queue_len) {
+	if (!fd_cache_num && !run_queue && !signal_queue_len) {
 		if (!exp) {
 			delta_ms      = MAX_DELAY_MS;
 			delta.tv_sec  = (MAX_DELAY_MS / 1000);
diff --git a/src/fd.c b/src/fd.c
index ad45f46..d2638d3 100644
--- a/src/fd.c
+++ b/src/fd.c
@@ -105,11 +105,10 @@ struct poller pollers[MAX_POLLERS];
 struct poller cur_poller;
 int nbpollers = 0;
 
-/* FD status is defined by the poller's status and by the speculative I/O list */
-int fd_nbspec = 0;             // number of speculative events in the list
-int fd_nbupdt = 0;             // number of updates in the list
-unsigned int *fd_spec = NULL;  // speculative I/O list
+unsigned int *fd_cache = NULL; // FD events cache
 unsigned int *fd_updt = NULL;  // FD updates list
+int fd_cache_num = 0;          // number of events in the cache
+int fd_nbupdt = 0;             // number of updates in the list
 
 /* Deletes an FD from the fdsets, and recomputes the maxfd limit.
  * The file descriptor is also closed.
@@ -146,8 +145,8 @@ void fd_process_spec_events()
 
 	/* now process speculative events if any */
 
-	for (spec_idx = 0; spec_idx < fd_nbspec; ) {
-		fd = fd_spec[spec_idx];
+	for (spec_idx = 0; spec_idx < fd_cache_num; ) {
+		fd = fd_cache[spec_idx];
 		e = fdtab[fd].state;
 
 		/*
@@ -176,7 +175,7 @@ void fd_process_spec_events()
 		/* if the fd was removed from the spec list, it has been
 		 * replaced by the next one that we don't want to skip !
 		 */
-		if (spec_idx < fd_nbspec && fd_spec[spec_idx] != fd)
+		if (spec_idx < fd_cache_num && fd_cache[spec_idx] != fd)
 			continue;
 
 		spec_idx++;
@@ -202,8 +201,8 @@ int init_pollers()
 	int p;
 	struct poller *bp;
 
-	if ((fd_spec = (uint32_t *)calloc(1, sizeof(uint32_t) * global.maxsock)) == NULL)
-		goto fail_spec;
+	if ((fd_cache = (uint32_t *)calloc(1, sizeof(uint32_t) * global.maxsock)) == NULL)
+		goto fail_cache;
 
 	if ((fd_updt = (uint32_t *)calloc(1, sizeof(uint32_t) * global.maxsock)) == NULL)
 		goto fail_updt;
@@ -225,8 +224,8 @@ int init_pollers()
 	return 0;
 
  fail_updt:
-	free(fd_spec);
- fail_spec:
+	free(fd_cache);
+ fail_cache:
 	return 0;
 }
 
@@ -246,9 +245,9 @@ void deinit_pollers() {
 	}
 
 	free(fd_updt);
-	free(fd_spec);
+	free(fd_cache);
 	fd_updt = NULL;
-	fd_spec = NULL;
+	fd_cache = NULL;
 }
 
 /*
-- 
1.8.3.2

