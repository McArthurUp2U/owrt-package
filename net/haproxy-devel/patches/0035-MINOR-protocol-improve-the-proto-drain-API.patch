From 7f4bcc312d51f6ac659b2aeb5bb44b9b4c0d8621 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Mon, 20 Jan 2014 11:26:12 +0100
Subject: [PATCH 35/41] MINOR: protocol: improve the proto->drain() API

It was not possible to know if the drain() function had hit an
EAGAIN, so now we change the API of this function to return :
  < 0 if EAGAIN was met
  = 0 if some data remain
  > 0 if a shutdown was received
---
 src/checks.c           | 4 ++--
 src/proto_tcp.c        | 8 ++++----
 src/stream_interface.c | 2 +-
 3 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/src/checks.c b/src/checks.c
index 52cf47c..4682b2c 100644
--- a/src/checks.c
+++ b/src/checks.c
@@ -1446,7 +1446,7 @@ static int wake_srv_chk(struct connection *conn)
 		 * sure want to abort the hard way.
 		 */
 		if (conn_ctrl_ready(conn) && !(conn->flags & CO_FL_SOCK_RD_SH)) {
-			if (!(conn->flags & CO_FL_WAIT_RD) && conn->ctrl->drain && conn->ctrl->drain(conn->t.sock.fd))
+			if (!(conn->flags & CO_FL_WAIT_RD) && conn->ctrl->drain && conn->ctrl->drain(conn->t.sock.fd) > 0)
 				fdtab[conn->t.sock.fd].linger_risk = 0;
 		}
 		conn_force_close(conn);
@@ -1665,7 +1665,7 @@ static struct task *process_chk(struct task *t)
 			 * server state to be suddenly changed.
 			 */
 			if (conn_ctrl_ready(conn) && !(conn->flags & CO_FL_SOCK_RD_SH)) {
-				if (!(conn->flags & CO_FL_WAIT_RD) && conn->ctrl->drain && conn->ctrl->drain(conn->t.sock.fd))
+				if (!(conn->flags & CO_FL_WAIT_RD) && conn->ctrl->drain && conn->ctrl->drain(conn->t.sock.fd) > 0)
 					fdtab[conn->t.sock.fd].linger_risk = 0;
 			}
 			conn_force_close(conn);
diff --git a/src/proto_tcp.c b/src/proto_tcp.c
index c1b0d7b..c02409d 100644
--- a/src/proto_tcp.c
+++ b/src/proto_tcp.c
@@ -525,9 +525,9 @@ int tcp_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)
 }
 
 /* Tries to drain any pending incoming data from the socket to reach the
- * receive shutdown. Returns non-zero if the shutdown was found, otherwise
- * zero. This is useful to decide whether we can close a connection cleanly
- * are we must kill it hard.
+ * receive shutdown. Returns positive if the shutdown was found, negative
+ * if EAGAIN was hit, otherwise zero. This is useful to decide whether we
+ * can close a connection cleanly are we must kill it hard.
  */
 int tcp_drain(int fd)
 {
@@ -546,7 +546,7 @@ int tcp_drain(int fd)
 
 		if (len < 0) {
 			if (errno == EAGAIN) /* connection not closed yet */
-				return 0;
+				return -1;
 			if (errno == EINTR)  /* oops, try again */
 				continue;
 			/* other errors indicate a dead connection, fine. */
diff --git a/src/stream_interface.c b/src/stream_interface.c
index f38ddc1..b9cb799 100644
--- a/src/stream_interface.c
+++ b/src/stream_interface.c
@@ -499,7 +499,7 @@ static void si_idle_conn_null_cb(struct connection *conn)
 		return;
 
 	if ((fdtab[conn->t.sock.fd].ev & (FD_POLL_ERR|FD_POLL_HUP)) ||
-	    (conn->ctrl->drain && conn->ctrl->drain(conn->t.sock.fd)))
+	    (conn->ctrl->drain && conn->ctrl->drain(conn->t.sock.fd) > 0))
 		conn->flags |= CO_FL_SOCK_RD_SH;
 
 	/* disable draining if we were called and have no drain function */
-- 
1.8.1.5

