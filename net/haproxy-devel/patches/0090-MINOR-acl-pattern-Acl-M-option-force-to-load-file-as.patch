From 9860c412587a3476b12397489fe75137dd08d271 Mon Sep 17 00:00:00 2001
From: Thierry FOURNIER <tfournier@exceliance.fr>
Date: Wed, 29 Jan 2014 14:23:29 +0100
Subject: [PATCH 090/103] MINOR: acl/pattern: Acl "-M" option force to load
 file as map file with two columns

---
 doc/configuration.txt | 7 +++++++
 src/acl.c             | 7 ++++++-
 2 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/doc/configuration.txt b/doc/configuration.txt
index a65db0d..f25f647 100644
--- a/doc/configuration.txt
+++ b/doc/configuration.txt
@@ -8909,6 +8909,7 @@ The following ACL flags are currently supported :
    -i : ignore case during matching of all subsequent patterns.
    -f : load patterns from a file.
    -m : use a specific pattern matching method
+   -M : load the file pointed by -f like a map file.
    -u : force the unique id of the ACL
    -- : force end of flags. Useful when a string looks like one of the flags.
 
@@ -8922,6 +8923,12 @@ a comment. Depending on the data type and match method, haproxy may load the
 lines into a binary tree, allowing very fast lookups. This is true for IPv4 and
 exact string matching. In this case, duplicates will automatically be removed.
 
+The "-M" flag allows an ACL to use a map file. If this flag is set, the file is
+parsed as two column file. The first column contains the patterns used by the
+ACL, and the second column contain the samples. The sample can be used later by
+a map. This can be useful in some rare cases where an ACL would just be used to
+check for the existence of a pattern in a map before a mapping is applied.
+
 The "-u" flag forces the unique id of the ACL. This unique id is used with the
 socket interface to identify ACL and dynamically change its values. Note that a
 file is always identified by its name even if an id is set.
diff --git a/src/acl.c b/src/acl.c
index 5576187..0e3f2bf 100644
--- a/src/acl.c
+++ b/src/acl.c
@@ -160,6 +160,7 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 	char *error;
 	struct pat_ref *ref;
 	struct pattern_expr *pattern_expr;
+	int load_as_map = 0;
 
 	/* First, we look for an ACL keyword. And if we don't find one, then
 	 * we look for a sample fetch expression starting with a sample fetch
@@ -417,6 +418,7 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 	 *   -i : ignore case for all patterns by default
 	 *   -f : read patterns from those files
 	 *   -m : force matching method (must be used before -f)
+	 *   -M : load the file as map file
 	 *   -u : force the unique id of the acl
 	 *   -- : everything after this is not an option
 	 */
@@ -451,7 +453,7 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 			snprintf(trash.str, trash.size, "acl(s) loaded from file '%s'", args[1]);
 			trash.str[trash.size - 1] = '\0';
 
-			if (!pattern_read_from_file(&expr->pat, PAT_REF_ACL, args[1], patflags | PAT_F_FROM_FILE, 0, err, trash.str))
+			if (!pattern_read_from_file(&expr->pat, PAT_REF_ACL, args[1], patflags | PAT_F_FROM_FILE, load_as_map, err, trash.str))
 				goto out_free_expr;
 			is_loaded = 1;
 			args++;
@@ -483,6 +485,9 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 			expr->pat.expect_type = pat_match_types[idx];
 			args++;
 		}
+		else if ((*args)[1] == 'M') {
+			load_as_map = 1;
+		}
 		else if ((*args)[1] == '-') {
 			args++;
 			break;
-- 
1.8.3.2

