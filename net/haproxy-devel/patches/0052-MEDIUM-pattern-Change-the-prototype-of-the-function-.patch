From 972028fa673c949bc2089cea384ac9dbdd0ce76c Mon Sep 17 00:00:00 2001
From: Thierry FOURNIER <tfournier@exceliance.fr>
Date: Thu, 23 Jan 2014 17:53:31 +0100
Subject: [PATCH 052/103] MEDIUM: pattern: Change the prototype of the function
 pattern_register().

Each pattern parser take only one string. This change is reported to the
function prototype of the function "pattern_register()". Now, it is
called with just one string and no need to browse the array of args.
---
 include/proto/pattern.h |   2 +-
 src/acl.c               |   5 +-
 src/dumpstats.c         |   6 +-
 src/map.c               |   5 +-
 src/pattern.c           | 213 +++++++++++++++++++++---------------------------
 5 files changed, 97 insertions(+), 134 deletions(-)

diff --git a/include/proto/pattern.h b/include/proto/pattern.h
index f48f5ae..87f635d 100644
--- a/include/proto/pattern.h
+++ b/include/proto/pattern.h
@@ -40,7 +40,7 @@
  * The function returns 1 if the processing is ok, return 0
  * if the parser fails, with <err> message filled.
  */
-int pattern_register(struct pattern_expr *expr, const char **args, struct sample_storage *smp, struct pattern **pattern, int patflags, char **err);
+int pattern_register(struct pattern_expr *expr, const char *arg, struct sample_storage *smp, struct pattern **pattern, int patflags, char **err);
 
 /* return the PAT_MATCH_* index for match name "name", or < 0 if not found */
 static inline int pat_find_match_name(const char *name)
diff --git a/src/acl.c b/src/acl.c
index 1ffc572..2a3756c 100644
--- a/src/acl.c
+++ b/src/acl.c
@@ -152,7 +152,6 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 	signed long long value, minor;
 	/* The following buffer contain two numbers, a ':' separator and the final \0. */
 	char buffer[NB_LLMAX_STR + 1 + NB_LLMAX_STR + 1];
-	const char *text[2];
 
 	/* First, we look for an ACL keyword. And if we don't find one, then
 	 * we look for a sample fetch expression starting with a sample fetch
@@ -570,9 +569,7 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 			}
 		}
 
-		text[0] = arg;
-		text[1] = "";
-		if (!pattern_register(&expr->pat, text, NULL, &pattern, patflags, err))
+		if (!pattern_register(&expr->pat, arg, NULL, &pattern, patflags, err))
 			goto out_free_pattern;
 		args++;
 	}
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 1e137fb..aa5aed2 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -1919,7 +1919,6 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 	}
 	else if (strcmp(args[0], "add") == 0) {
 		if (strcmp(args[1], "map") == 0) {
-			const char *params[2];
 			struct pattern *pat;
 			struct map_entry *ent;
 			struct sample_storage *smp;
@@ -1931,9 +1930,6 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				return 1;
 			}
 
-			params[0] = args[3];
-			params[1] = "";
-
 			/* Lookup the reference in the maps. */
 			appctx->ctx.map.ref = map_get_reference(args[2]);
 			if (!appctx->ctx.map.ref) {
@@ -2012,7 +2008,7 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 				else
 					pat = NULL;
 
-				if (!pattern_register(appctx->ctx.map.desc->pat, params, smp, &pat, 0, NULL)) {
+				if (!pattern_register(appctx->ctx.map.desc->pat, args[3], smp, &pat, 0, NULL)) {
 					free(smp);
 					continue;
 				}
diff --git a/src/map.c b/src/map.c
index c3a13a7..ff1448c 100644
--- a/src/map.c
+++ b/src/map.c
@@ -307,7 +307,6 @@ static int map_parse_and_index(struct map_descriptor *desc,
                                char **err)
 {
 	struct sample_storage *smp;
-	const char *args[2];
 
 	/* use new smp for storing value */
 	smp = calloc(1, sizeof(*smp));
@@ -322,9 +321,7 @@ static int map_parse_and_index(struct map_descriptor *desc,
 	}
 
 	/* register key */
-	args[0] = ent->key;
-	args[1] = "";
-	if (!pattern_register(desc->pat, args, smp, pattern, patflags, err))
+	if (!pattern_register(desc->pat, ent->key, smp, pattern, patflags, err))
 		return 0;
 
 	return 1;
diff --git a/src/pattern.c b/src/pattern.c
index 7013851..30fdcc6 100644
--- a/src/pattern.c
+++ b/src/pattern.c
@@ -790,152 +790,129 @@ void pattern_init_expr(struct pattern_expr *expr)
  * return -1 if the parser fail. The err message is filled.
  * return -2 if out of memory
  */
-int pattern_register(struct pattern_expr *expr, const char **args,
-                         struct sample_storage *smp,
-                         struct pattern **pattern,
-                         int patflags, char **err)
+int pattern_register(struct pattern_expr *expr, const char *arg,
+                     struct sample_storage *smp,
+                     struct pattern **pattern,
+                     int patflags, char **err)
 {
 	unsigned int mask = 0;
 	struct pat_idx_elt *node;
 	int len;
 	int ret;
 
-	/* eat args */
-	while (**args) {
-
-		/* we keep the previous pattern along iterations as long as it's not used */
-		if (!*pattern)
-			*pattern = (struct pattern *)malloc(sizeof(**pattern));
-		if (!*pattern) {
-			memprintf(err, "out of memory while loading pattern");
-			return 0;
-		}
-
-		memset(*pattern, 0, sizeof(**pattern));
-		(*pattern)->flags = patflags;
+	/* we keep the previous pattern along iterations as long as it's not used */
+	if (!*pattern)
+		*pattern = (struct pattern *)malloc(sizeof(**pattern));
+	if (!*pattern) {
+		memprintf(err, "out of memory while loading pattern");
+		return 0;
+	}
 
-		ret = expr->parse(args[0], *pattern, PAT_U_COMPILE, err);
-		if (!ret)
-			return 0;
+	memset(*pattern, 0, sizeof(**pattern));
+	(*pattern)->flags = patflags;
 
-		/* each parser return the number of args eated */
-		args += ret;
+	ret = expr->parse(arg, *pattern, PAT_U_COMPILE, err);
+	if (!ret)
+		return 0;
 
-		/*
-		 *
-		 * SMP_T_CSTR tree indexation
-		 *
-		 * The match "pat_match_str()" can use tree.
-		 *
+	if (expr->match == pat_match_str) {
+		/* SMP_T_CSTR tree indexation.
+		 * The match "pat_match_str()" can use trees.
 		 */
-		if (expr->match == pat_match_str) {
-
+		if ((*pattern)->flags & PAT_F_IGNORE_CASE) {
 			/* If the flag PAT_F_IGNORE_CASE is set, we cannot use trees */
-			if ((*pattern)->flags & PAT_F_IGNORE_CASE)
-				goto just_chain_the_pattern;
-
-			/* Process the key len */
-			len = strlen((*pattern)->ptr.str) + 1;
+			goto just_chain_the_pattern;
+		}
 
-			/* node memory allocation */
-			node = calloc(1, sizeof(*node) + len);
-			if (!node) {
-				memprintf(err, "out of memory while loading pattern");
-				return 0;
-			}
+		/* Process the key len */
+		len = strlen((*pattern)->ptr.str) + 1;
 
-			/* copy the pointer to sample associated to this node */
-			node->smp = smp;
+		/* node memory allocation */
+		node = calloc(1, sizeof(*node) + len);
+		if (!node) {
+			memprintf(err, "out of memory while loading pattern");
+			return 0;
+		}
 
-			/* copy the string */
-			memcpy(node->node.key, (*pattern)->ptr.str, len);
+		/* copy the pointer to sample associated to this node */
+		node->smp = smp;
 
-			/* the "map_parser_str()" function always duplicate string information */
-			free((*pattern)->ptr.str);
-			(*pattern)->ptr.str = NULL;
+		/* copy the string */
+		memcpy(node->node.key, (*pattern)->ptr.str, len);
 
-			/* we pre-set the data pointer to the tree's head so that functions
-			 * which are able to insert in a tree know where to do that.
-			 *
-			 * because "val" is an "union", the previous data are crushed.
-			 */
-			(*pattern)->flags |= PAT_F_TREE;
-			(*pattern)->val.tree = &expr->pattern_tree;
+		/* the "map_parser_str()" function always duplicate string information */
+		free((*pattern)->ptr.str);
+		(*pattern)->ptr.str = NULL;
 
-			/* index the new node */
-			if (ebst_insert((*pattern)->val.tree, &node->node) != &node->node)
-				free(node); /* was a duplicate */
-		}
-
-		/*
-		 *
-		 * SMP_T_IPV4 tree indexation
-		 *
-		 * The match "pat_match_ip()" can use tree.
+		/* we pre-set the data pointer to the tree's head so that functions
+		 * which are able to insert in a tree know where to do that.
 		 *
+		 * because "val" is an "union", the previous data are crushed.
 		 */
-		else if (expr->match == pat_match_ip) {
+		(*pattern)->flags |= PAT_F_TREE;
+		(*pattern)->val.tree = &expr->pattern_tree;
 
+		/* index the new node */
+		if (ebst_insert((*pattern)->val.tree, &node->node) != &node->node)
+			free(node); /* was a duplicate */
+	}
+	else if (expr->match == pat_match_ip) {
+		/* SMP_T_IPV4 tree indexation
+		 * The match "pat_match_ip()" can use tree.
+		 */
+		if ((*pattern)->type != SMP_T_IPV4) {
 			/* Only IPv4 can be indexed */
-			if ((*pattern)->type != SMP_T_IPV4)
-				goto just_chain_the_pattern;
-
-			/* in IPv4 case, check if the mask is contiguous so that we can
-			 * insert the network into the tree. A continuous mask has only
-			 * ones on the left. This means that this mask + its lower bit
-			 * added once again is null.
-			 */
-			mask = ntohl((*pattern)->val.ipv4.mask.s_addr);
-			if (mask + (mask & -mask) != 0)
-				goto just_chain_the_pattern;
-			mask = mask ? 33 - flsnz(mask & -mask) : 0; /* equals cidr value */
-
-			/* node memory allocation */
-			node = calloc(1, sizeof(*node) + 4);
-			if (!node) {
-				memprintf(err, "out of memory while loading pattern");
-				return 0;
-			}
-
-			/* copy the pointer to sample associated to this node */
-			node->smp = smp;
+			goto just_chain_the_pattern;
+		}
 
-			/* FIXME: insert <addr>/<mask> into the tree here */
-			memcpy(node->node.key, &(*pattern)->val.ipv4.addr, 4); /* network byte order */
+		/* in IPv4 case, check if the mask is contiguous so that we can
+		 * insert the network into the tree. A continuous mask has only
+		 * ones on the left. This means that this mask + its lower bit
+		 * added once again is null.
+		 */
+		mask = ntohl((*pattern)->val.ipv4.mask.s_addr);
+		if (mask + (mask & -mask) != 0)
+			goto just_chain_the_pattern;
+		mask = mask ? 33 - flsnz(mask & -mask) : 0; /* equals cidr value */
+
+		/* node memory allocation */
+		node = calloc(1, sizeof(*node) + 4);
+		if (!node) {
+			memprintf(err, "out of memory while loading pattern");
+			return 0;
+		}
 
-			/* we pre-set the data pointer to the tree's head so that functions
-			 * which are able to insert in a tree know where to do that.
-			 *
-			 * because "val" is an "union", the previous data are crushed.
-			 */
-			(*pattern)->flags |= PAT_F_TREE;
-			(*pattern)->val.tree = &expr->pattern_tree;
+		/* copy the pointer to sample associated to this node */
+		node->smp = smp;
 
-			/* Index the new node
-			 * FIXME: insert <addr>/<mask> into the tree here
-			 */
-			node->node.node.pfx = mask;
-			if (ebmb_insert_prefix((*pattern)->val.tree, &node->node, 4) != &node->node)
-				free(node); /* was a duplicate */
-		}
+		/* FIXME: insert <addr>/<mask> into the tree here */
+		memcpy(node->node.key, &(*pattern)->val.ipv4.addr, 4); /* network byte order */
 
-		/*
-		 *
-		 * if the parser did not feed the tree, let's chain the pattern to the list
+		/* we pre-set the data pointer to the tree's head so that functions
+		 * which are able to insert in a tree know where to do that.
 		 *
+		 * because "val" is an "union", the previous data are crushed.
 		 */
-		else {
+		(*pattern)->flags |= PAT_F_TREE;
+		(*pattern)->val.tree = &expr->pattern_tree;
 
+		/* Index the new node
+		 * FIXME: insert <addr>/<mask> into the tree here
+		 */
+		node->node.node.pfx = mask;
+		if (ebmb_insert_prefix((*pattern)->val.tree, &node->node, 4) != &node->node)
+			free(node); /* was a duplicate */
+	}
+	else {
 just_chain_the_pattern:
+		/* if the parser did not feed the tree, let's chain the pattern to the list */
+		LIST_ADDQ(&expr->patterns, &(*pattern)->list);
 
-			LIST_ADDQ(&expr->patterns, &(*pattern)->list);
+		/* copy the pointer to sample associated to this node */
+		(*pattern)->smp = smp;
 
-			/* copy the pointer to sample associated to this node */
-			(*pattern)->smp = smp;
-
-			/* get a new one */
-			*pattern = NULL;
-		}
+		/* get a new one */
+		*pattern = NULL;
 	}
 
 	return 1;
@@ -955,7 +932,6 @@ int pattern_read_from_file(struct pattern_expr *expr,
 	int ret = 0;
 	int line = 0;
 	int code;
-	const char *args[2];
 
 	file = fopen(filename, "r");
 	if (!file) {
@@ -990,10 +966,7 @@ int pattern_read_from_file(struct pattern_expr *expr,
 		if (c == arg)
 			continue;
 
-		args[0] = arg;
-		args[1] = "";
-
-		code = pattern_register(expr, args, NULL, &pattern, patflags, err);
+		code = pattern_register(expr, arg, NULL, &pattern, patflags, err);
 		if (code == -2) {
 			memprintf(err, "out of memory when loading patterns from file <%s>", filename);
 			goto out_close;
-- 
1.8.3.2

