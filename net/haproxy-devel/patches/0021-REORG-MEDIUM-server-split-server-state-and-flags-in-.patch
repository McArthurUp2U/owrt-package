From c93cd16b6c9d4033aff7991f5ba0745005fa4caf Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Tue, 13 May 2014 15:54:22 +0200
Subject: [PATCH 21/54] REORG/MEDIUM: server: split server state and flags in
 two different variables

Till now, the server's state and flags were all saved as a single bit
field. It causes some difficulties because we'd like to have an enum
for the state and separate flags.

This commit starts by splitting them in two distinct fields. The first
one is srv->state (with its counter-part srv->prev_state) which are now
enums, but which still contain bits (SRV_STF_*).

The flags now lie in their own field (srv->flags).

The function srv_is_usable() was updated to use the enum as input, since
it already used to deal only with the state.

Note that currently, the maintenance mode is still in the state for
simplicity, but it must move as well.
---
 include/proto/backend.h | 12 +++----
 include/types/server.h  | 25 +++++++-------
 src/backend.c           | 12 +++----
 src/cfgparse.c          |  6 ++--
 src/checks.c            | 88 ++++++++++++++++++++++++-------------------------
 src/dumpstats.c         | 60 ++++++++++++++++-----------------
 src/haproxy.c           |  2 +-
 src/lb_chash.c          | 10 +++---
 src/lb_fas.c            | 10 +++---
 src/lb_fwlc.c           | 10 +++---
 src/lb_fwrr.c           | 22 ++++++-------
 src/lb_map.c            | 10 +++---
 src/proto_http.c        |  8 ++---
 src/queue.c             |  2 +-
 src/server.c            | 23 ++++++-------
 src/session.c           |  6 ++--
 16 files changed, 154 insertions(+), 152 deletions(-)

diff --git a/include/proto/backend.h b/include/proto/backend.h
index ac9e190..8043613 100644
--- a/include/proto/backend.h
+++ b/include/proto/backend.h
@@ -57,13 +57,13 @@ static void inline be_set_sess_last(struct proxy *be)
  */
 static inline int srv_is_usable(const struct server *srv)
 {
-	int state = srv->state;
+	enum srv_state state = srv->state;
 
 	if (!srv->eweight)
 		return 0;
-	if (state & (SRV_GOINGDOWN | SRV_MAINTAIN))
+	if (state & (SRV_STF_GOINGDOWN | SRV_STF_MAINTAIN))
 		return 0;
-	if (!(state & SRV_RUNNING))
+	if (!(state & SRV_STF_RUNNING))
 		return 0;
 	return 1;
 }
@@ -73,13 +73,13 @@ static inline int srv_is_usable(const struct server *srv)
  */
 static inline int srv_was_usable(const struct server *srv)
 {
-	int state = srv->prev_state;
+	enum srv_state state = srv->prev_state;
 
 	if (!srv->prev_eweight)
 		return 0;
-	if (state & (SRV_GOINGDOWN | SRV_MAINTAIN))
+	if (state & (SRV_STF_GOINGDOWN | SRV_STF_MAINTAIN))
 		return 0;
-	if (!(state & SRV_RUNNING))
+	if (!(state & SRV_STF_RUNNING))
 		return 0;
 	return 1;
 }
diff --git a/include/types/server.h b/include/types/server.h
index 0897f9a..6b77b15 100644
--- a/include/types/server.h
+++ b/include/types/server.h
@@ -43,17 +43,18 @@
 #include <types/checks.h>
 
 
+/* server states, still used as cumulative flags */
+enum srv_state {
+	SRV_STF_RUNNING    = 0x1,        /* the server is UP */
+	SRV_STF_GOINGDOWN  = 0x2,        /* the server is going down (eg: 404) */
+	SRV_STF_WARMINGUP  = 0x4,        /* the server is warming up after a failure */
+	SRV_STF_MAINTAIN   = 0x8,        /* the server is in maintenance mode */
+};
+
 /* server flags */
-#define SRV_RUNNING	0x0001	/* the server is UP */
-#define SRV_BACKUP	0x0002	/* this server is a backup server */
-#define SRV_MAPPORTS	0x0004	/* this server uses mapped ports */
-/* unused: 0x0008 */
-/* unused: 0x0010 */
-#define SRV_GOINGDOWN	0x0020	/* this server says that it's going down (404) */
-#define SRV_WARMINGUP	0x0040	/* this server is warming up after a failure */
-#define SRV_MAINTAIN	0x0080	/* this server is in maintenance mode */
-/* unused: 0x0100, 0x0200, 0x0400, 0x0800 */
-#define SRV_NON_STICK	0x1000	/* never add connections allocated to this server to a stick table */
+#define SRV_F_BACKUP       0x0001        /* this server is a backup server */
+#define SRV_F_MAPPORTS     0x0002        /* this server uses mapped ports */
+#define SRV_F_NON_STICK    0x0004        /* never add connections allocated to this server to a stick table */
 
 /* configured server options for send-proxy (server->pp_opts) */
 #define SRV_PP_V1          0x0001        /* proxy protocol version 1 */
@@ -103,9 +104,9 @@ struct tree_occ {
 
 struct server {
 	enum obj_type obj_type;                 /* object type == OBJ_TYPE_SERVER */
+	enum srv_state state, prev_state;       /* server state among SRV_STF_* */
+	unsigned char flags;                    /* server flags (SRV_F_*) */
 	struct server *next;
-	int state;				/* server state (SRV_*) */
-	int prev_state;				/* server state before last change (SRV_*) */
 	int cklen;				/* the len of the cookie, to speed up checks */
 	int rdr_len;				/* the length of the redirection prefix */
 	char *cookie;				/* the id set in the cookie */
diff --git a/src/backend.c b/src/backend.c
index e9043b4..3ce7415 100644
--- a/src/backend.c
+++ b/src/backend.c
@@ -100,7 +100,7 @@ void recount_servers(struct proxy *px)
 		if (!srv_is_usable(srv))
 			continue;
 
-		if (srv->state & SRV_BACKUP) {
+		if (srv->flags & SRV_F_BACKUP) {
 			if (!px->srv_bck &&
 			    !(px->options & PR_O_USE_ALL_BK))
 				px->lbprm.fbck = srv;
@@ -767,7 +767,7 @@ int assign_server_address(struct session *s)
 
 		/* if this server remaps proxied ports, we'll use
 		 * the port the client connected to with an offset. */
-		if ((objt_server(s->target)->state & SRV_MAPPORTS) && cli_conn) {
+		if ((objt_server(s->target)->flags & SRV_F_MAPPORTS) && cli_conn) {
 			int base_port;
 
 			conn_get_to_addr(cli_conn);
@@ -1242,7 +1242,7 @@ int tcp_persist_rdp_cookie(struct session *s, struct channel *req, int an_bit)
 	while (srv) {
 		if (srv->addr.ss_family == AF_INET &&
 		    memcmp(&addr, &(srv->addr), sizeof(addr)) == 0) {
-			if ((srv->state & SRV_RUNNING) || (px->options & PR_O_PERSIST)) {
+			if ((srv->state & SRV_STF_RUNNING) || (px->options & PR_O_PERSIST)) {
 				/* we found the server and it is usable */
 				s->flags |= SN_DIRECT | SN_ASSIGNED;
 				s->target = &srv->obj_type;
@@ -1489,8 +1489,8 @@ smp_fetch_srv_is_up(struct proxy *px, struct session *l4, void *l7, unsigned int
 
 	smp->flags = SMP_F_VOL_TEST;
 	smp->type = SMP_T_BOOL;
-	if (!(srv->state & SRV_MAINTAIN) &&
-	    (!(srv->check.state & CHK_ST_CONFIGURED) || (srv->state & SRV_RUNNING)))
+	if (!(srv->state & SRV_STF_MAINTAIN) &&
+	    (!(srv->check.state & CHK_ST_CONFIGURED) || (srv->state & SRV_STF_RUNNING)))
 		smp->data.uint = 1;
 	else
 		smp->data.uint = 0;
@@ -1512,7 +1512,7 @@ smp_fetch_connslots(struct proxy *px, struct session *l4, void *l7, unsigned int
 	smp->data.uint = 0;
 
 	for (iterator = args->data.prx->srv; iterator; iterator = iterator->next) {
-		if ((iterator->state & SRV_RUNNING) == 0)
+		if ((iterator->state & SRV_STF_RUNNING) == 0)
 			continue;
 
 		if (iterator->maxconn == 0 || iterator->maxqueue == 0) {
diff --git a/src/cfgparse.c b/src/cfgparse.c
index 5edb773..a002cb2 100644
--- a/src/cfgparse.c
+++ b/src/cfgparse.c
@@ -6617,8 +6617,8 @@ out_uri_auth_compat:
 				}
 
 				/* if the other server is forced disabled, we have to do the same here */
-				if (srv->state & SRV_MAINTAIN) {
-					newsrv->state &= ~SRV_RUNNING;
+				if (srv->state & SRV_STF_MAINTAIN) {
+					newsrv->state &= ~SRV_STF_RUNNING;
 					newsrv->check.health = 0;
 					newsrv->agent.health = 0;
 				}
@@ -6754,7 +6754,7 @@ out_uri_auth_compat:
 				err_code |= ERR_WARN;
 			}
 
-			if ((newsrv->state & SRV_MAPPORTS) && (curproxy->options2 & PR_O2_RDPC_PRST)) {
+			if ((newsrv->flags & SRV_F_MAPPORTS) && (curproxy->options2 & PR_O2_RDPC_PRST)) {
 				Warning("config : %s '%s' : RDP cookie persistence will not work for server '%s' because it lacks an explicit port number.\n",
 				        proxy_type_str(curproxy), curproxy->id, newsrv->id);
 				err_code |= ERR_WARN;
diff --git a/src/checks.c b/src/checks.c
index 2fbda11..9228c89 100644
--- a/src/checks.c
+++ b/src/checks.c
@@ -182,7 +182,7 @@ static void server_status_printf(struct chunk *msg, struct server *s, struct che
 	}
 
 	if (xferred >= 0) {
-		if (!(s->state & SRV_RUNNING))
+		if (!(s->state & SRV_STF_RUNNING))
 			chunk_appendf(msg, ". %d active and %d backup servers left.%s"
 				" %d sessions active, %d requeued, %d remaining in queue",
 				s->proxy->srv_act, s->proxy->srv_bck,
@@ -247,8 +247,8 @@ static void set_server_check_status(struct check *check, short status, const cha
 	    ((status != prev_status) ||
 	    ((check->health != 0) && (check->result == CHK_RES_FAILED)) ||
 	    (((check->health != check->rise + check->fall - 1)) && (check->result >= CHK_RES_PASSED)))) {
-
-		int health, rise, fall, state;
+		int health, rise, fall;
+		enum srv_state state;
 
 		chunk_reset(&trash);
 
@@ -264,7 +264,7 @@ static void set_server_check_status(struct check *check, short status, const cha
 				health--; /* still good */
 			} else {
 				if (health == rise)
-					state &= ~(SRV_RUNNING | SRV_GOINGDOWN);
+					state &= ~(SRV_STF_RUNNING | SRV_STF_GOINGDOWN);
 
 				health = 0;
 			}
@@ -276,7 +276,7 @@ static void set_server_check_status(struct check *check, short status, const cha
 				health++; /* was bad, stays for a while */
 
 				if (health == rise)
-					state |= SRV_RUNNING;
+					state |= SRV_STF_RUNNING;
 
 				if (health >= rise)
 					health = rise + fall - 1; /* OK now */
@@ -292,7 +292,7 @@ static void set_server_check_status(struct check *check, short status, const cha
 
 		chunk_appendf(&trash,
 		             "Health check for %sserver %s/%s %s%s",
-		             s->state & SRV_BACKUP ? "backup " : "",
+		             s->flags & SRV_F_BACKUP ? "backup " : "",
 		             s->proxy->id, s->id,
 		             (check->result == CHK_RES_CONDPASS) ? "conditionally ":"",
 		             (check->result >= CHK_RES_PASSED)   ? "succeeded":"failed");
@@ -300,9 +300,9 @@ static void set_server_check_status(struct check *check, short status, const cha
 		server_status_printf(&trash, s, check, -1);
 
 		chunk_appendf(&trash, ", status: %d/%d %s",
-		             (state & SRV_RUNNING) ? (health - rise + 1) : (health),
-		             (state & SRV_RUNNING) ? (fall) : (rise),
-			     (state & SRV_RUNNING) ? (s->uweight?"UP":"DRAIN"):"DOWN");
+		             (state & SRV_STF_RUNNING) ? (health - rise + 1) : (health),
+		             (state & SRV_STF_RUNNING) ? (fall) : (rise),
+			     (state & SRV_STF_RUNNING) ? (s->uweight?"UP":"DRAIN"):"DOWN");
 
 		Warning("%s.\n", trash.str);
 		send_log(s->proxy, LOG_NOTICE, "%s.\n", trash.str);
@@ -397,7 +397,7 @@ static void shutdown_backup_sessions(struct proxy *px, int why)
 	struct server *srv;
 
 	for (srv = px->srv; srv != NULL; srv = srv->next)
-		if (srv->state & SRV_BACKUP)
+		if (srv->flags & SRV_F_BACKUP)
 			shutdown_sessions(srv, why);
 }
 
@@ -412,16 +412,16 @@ void set_server_down(struct check *check)
 	struct server *srv;
 	int xferred;
 
-	if (s->state & SRV_MAINTAIN) {
+	if (s->state & SRV_STF_MAINTAIN) {
 		check->health = check->rise;
 	}
 
-	if ((s->state & SRV_RUNNING && check->health == check->rise) || s->track) {
-		int srv_was_paused = s->state & SRV_GOINGDOWN;
+	if ((s->state & SRV_STF_RUNNING && check->health == check->rise) || s->track) {
+		int srv_was_paused = s->state & SRV_STF_GOINGDOWN;
 		int prev_srv_count = s->proxy->srv_bck + s->proxy->srv_act;
 
 		s->last_change = now.tv_sec;
-		s->state &= ~(SRV_RUNNING | SRV_GOINGDOWN);
+		s->state &= ~(SRV_STF_RUNNING | SRV_STF_GOINGDOWN);
 		if (s->proxy->lbprm.set_server_status_down)
 			s->proxy->lbprm.set_server_status_down(s);
 
@@ -436,13 +436,13 @@ void set_server_down(struct check *check)
 
 		chunk_reset(&trash);
 
-		if (s->state & SRV_MAINTAIN) {
+		if (s->state & SRV_STF_MAINTAIN) {
 			chunk_appendf(&trash,
-			             "%sServer %s/%s is DOWN for maintenance", s->state & SRV_BACKUP ? "Backup " : "",
+			             "%sServer %s/%s is DOWN for maintenance", s->flags & SRV_F_BACKUP ? "Backup " : "",
 			             s->proxy->id, s->id);
 		} else {
 			chunk_appendf(&trash,
-			             "%sServer %s/%s is DOWN", s->state & SRV_BACKUP ? "Backup " : "",
+			             "%sServer %s/%s is DOWN", s->flags & SRV_F_BACKUP ? "Backup " : "",
 			             s->proxy->id, s->id);
 
 			server_status_printf(&trash, s,
@@ -463,7 +463,7 @@ void set_server_down(struct check *check)
 		s->counters.down_trans++;
 
 		for (srv = s->trackers; srv; srv = srv->tracknext)
-			if (!(srv->state & SRV_MAINTAIN))
+			if (!(srv->state & SRV_STF_MAINTAIN))
 				/* Only notify tracking servers that are not already in maintenance. */
 				set_server_down(&srv->check);
 	}
@@ -476,9 +476,9 @@ void set_server_up(struct check *check) {
 	struct server *s = check->server;
 	struct server *srv;
 	int xferred;
-	unsigned int old_state = s->state;
+	enum srv_state old_state = s->state;
 
-	if (s->state & SRV_MAINTAIN) {
+	if (s->state & SRV_STF_MAINTAIN) {
 		check->health = check->rise;
 	}
 
@@ -498,12 +498,12 @@ void set_server_up(struct check *check) {
 			s->down_time += now.tv_sec - s->last_change;
 
 		s->last_change = now.tv_sec;
-		s->state |= SRV_RUNNING;
-		s->state &= ~SRV_MAINTAIN;
+		s->state |= SRV_STF_RUNNING;
+		s->state &= ~SRV_STF_MAINTAIN;
 		s->check.state &= ~CHK_ST_PAUSED;
 
 		if (s->slowstart > 0) {
-			s->state |= SRV_WARMINGUP;
+			s->state |= SRV_STF_WARMINGUP;
 			task_schedule(s->warmup, tick_add(now_ms, MS_TO_TICKS(MAX(1000, s->slowstart / 20))));
 		}
 
@@ -515,7 +515,7 @@ void set_server_up(struct check *check) {
 		 * on all backup servers.
 		 */
 		if ((s->onmarkedup & HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS) &&
-		    !(s->state & SRV_BACKUP) && s->eweight)
+		    !(s->flags & SRV_F_BACKUP) && s->eweight)
 			shutdown_backup_sessions(s->proxy, SN_ERR_UP);
 
 		/* check if we can handle some connections queued at the proxy. We
@@ -525,13 +525,13 @@ void set_server_up(struct check *check) {
 
 		chunk_reset(&trash);
 
-		if (old_state & SRV_MAINTAIN) {
+		if (old_state & SRV_STF_MAINTAIN) {
 			chunk_appendf(&trash,
-			             "%sServer %s/%s is UP (leaving maintenance)", s->state & SRV_BACKUP ? "Backup " : "",
+			             "%sServer %s/%s is UP (leaving maintenance)", s->flags & SRV_F_BACKUP ? "Backup " : "",
 			             s->proxy->id, s->id);
 		} else {
 			chunk_appendf(&trash,
-			             "%sServer %s/%s is UP", s->state & SRV_BACKUP ? "Backup " : "",
+			             "%sServer %s/%s is UP", s->flags & SRV_F_BACKUP ? "Backup " : "",
 			             s->proxy->id, s->id);
 
 			server_status_printf(&trash, s,
@@ -543,7 +543,7 @@ void set_server_up(struct check *check) {
 		send_log(s->proxy, LOG_NOTICE, "%s.\n", trash.str);
 
 		for (srv = s->trackers; srv; srv = srv->tracknext)
-			if (!(srv->state & SRV_MAINTAIN))
+			if (!(srv->state & SRV_STF_MAINTAIN))
 				/* Only notify tracking servers if they're not in maintenance. */
 				set_server_up(&srv->check);
 	}
@@ -559,7 +559,7 @@ static void set_server_disabled(struct check *check) {
 	struct server *srv;
 	int xferred;
 
-	s->state |= SRV_GOINGDOWN;
+	s->state |= SRV_STF_GOINGDOWN;
 	if (s->proxy->lbprm.set_server_status_down)
 		s->proxy->lbprm.set_server_status_down(s);
 
@@ -573,7 +573,7 @@ static void set_server_disabled(struct check *check) {
 
 	chunk_appendf(&trash,
 	             "Load-balancing on %sServer %s/%s is disabled",
-	             s->state & SRV_BACKUP ? "Backup " : "",
+	             s->flags & SRV_F_BACKUP ? "Backup " : "",
 	             s->proxy->id, s->id);
 
 	server_status_printf(&trash, s,
@@ -596,7 +596,7 @@ static void set_server_enabled(struct check *check) {
 	struct server *srv;
 	int xferred;
 
-	s->state &= ~SRV_GOINGDOWN;
+	s->state &= ~SRV_STF_GOINGDOWN;
 	if (s->proxy->lbprm.set_server_status_up)
 		s->proxy->lbprm.set_server_status_up(s);
 
@@ -609,7 +609,7 @@ static void set_server_enabled(struct check *check) {
 
 	chunk_appendf(&trash,
 	             "Load-balancing on %sServer %s/%s is enabled again",
-	             s->state & SRV_BACKUP ? "Backup " : "",
+	             s->flags & SRV_F_BACKUP ? "Backup " : "",
 	             s->proxy->id, s->id);
 
 	server_status_printf(&trash, s,
@@ -745,13 +745,13 @@ static int httpchk_build_status_header(struct server *s, char *buffer, int size)
 
 	if (!(s->check.state & CHK_ST_ENABLED))
 		sv_state = 6;
-	else if (s->state & SRV_RUNNING) {
+	else if (s->state & SRV_STF_RUNNING) {
 		if (s->check.health == s->check.rise + s->check.fall - 1)
 			sv_state = 3; /* UP */
 		else
 			sv_state = 2; /* going down */
 
-		if (s->state & SRV_GOINGDOWN)
+		if (s->state & SRV_STF_GOINGDOWN)
 			sv_state += 2;
 	} else {
 		if (s->check.health)
@@ -762,8 +762,8 @@ static int httpchk_build_status_header(struct server *s, char *buffer, int size)
 
 	hlen += snprintf(buffer + hlen, size - hlen,
 			     srv_hlt_st[sv_state],
-			     (s->state & SRV_RUNNING) ? (s->check.health - s->check.rise + 1) : (s->check.health),
-			     (s->state & SRV_RUNNING) ? (s->check.fall) : (s->check.rise));
+			     (s->state & SRV_STF_RUNNING) ? (s->check.health - s->check.rise + 1) : (s->check.health),
+			     (s->state & SRV_STF_RUNNING) ? (s->check.fall) : (s->check.rise));
 
 	hlen += snprintf(buffer + hlen,  size - hlen, "; name=%s/%s; node=%s; weight=%d/%d; scur=%d/%d; qcur=%d",
 			     s->proxy->id, s->id,
@@ -773,7 +773,7 @@ static int httpchk_build_status_header(struct server *s, char *buffer, int size)
 			     s->cur_sess, s->proxy->beconn - s->proxy->nbpend,
 			     s->nbpend);
 
-	if ((s->state & SRV_WARMINGUP) &&
+	if ((s->state & SRV_STF_WARMINGUP) &&
 	    now.tv_sec < s->last_change + s->slowstart &&
 	    now.tv_sec >= s->last_change) {
 		ratio = MAX(1, 100 * (now.tv_sec - s->last_change) / s->slowstart);
@@ -1084,7 +1084,7 @@ static void event_srv_chk_r(struct connection *conn)
 		desc = ltrim(check->bi->data + 12, ' ');
 		
 		if ((s->proxy->options & PR_O_DISABLE404) &&
-			 (s->state & SRV_RUNNING) && (check->code == 404)) {
+			 (s->state & SRV_STF_RUNNING) && (check->code == 404)) {
 			/* 404 may be accepted as "stopping" only if the server was up */
 			cut_crlf(desc);
 			set_server_check_status(check, HCHK_STATUS_L7OKCD, desc);
@@ -1480,7 +1480,7 @@ static struct task *server_warmup(struct task *t)
 
 	/* by default, plan on stopping the task */
 	t->expire = TICK_ETERNITY;
-	if ((s->state & (SRV_RUNNING|SRV_WARMINGUP|SRV_MAINTAIN)) != (SRV_RUNNING|SRV_WARMINGUP))
+	if ((s->state & (SRV_STF_RUNNING|SRV_STF_WARMINGUP|SRV_STF_MAINTAIN)) != (SRV_STF_RUNNING|SRV_STF_WARMINGUP))
 		return t;
 
 	server_recalc_eweight(s);
@@ -1491,7 +1491,7 @@ static struct task *server_warmup(struct task *t)
 	/* get back there in 1 second or 1/20th of the slowstart interval,
 	 * whichever is greater, resulting in small 5% steps.
 	 */
-	if (s->state & SRV_WARMINGUP)
+	if (s->state & SRV_STF_WARMINGUP)
 		t->expire = tick_add(now_ms, MS_TO_TICKS(MAX(1000, s->slowstart / 20)));
 	return t;
 }
@@ -1700,14 +1700,14 @@ static struct task *process_chk(struct task *t)
 			check_failed(check);
 		else {  /* check was OK */
 			/* we may have to add/remove this server from the LB group */
-			if ((s->state & SRV_RUNNING) && (s->proxy->options & PR_O_DISABLE404)) {
-				if ((s->state & SRV_GOINGDOWN) && (check->result != CHK_RES_CONDPASS))
+			if ((s->state & SRV_STF_RUNNING) && (s->proxy->options & PR_O_DISABLE404)) {
+				if ((s->state & SRV_STF_GOINGDOWN) && (check->result != CHK_RES_CONDPASS))
 					set_server_enabled(check);
-				else if (!(s->state & SRV_GOINGDOWN) && (check->result == CHK_RES_CONDPASS))
+				else if (!(s->state & SRV_STF_GOINGDOWN) && (check->result == CHK_RES_CONDPASS))
 					set_server_disabled(check);
 			}
 
-			if (!(s->state & SRV_MAINTAIN) &&
+			if (!(s->state & SRV_STF_MAINTAIN) &&
 			    check->health < check->rise + check->fall - 1) {
 				check->health++; /* was bad, stays for a while */
 				set_server_up(check);
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 1d9531f..47328ce 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -1710,17 +1710,17 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			if (!sv)
 				return 1;
 
-			if (sv->state & SRV_MAINTAIN) {
+			if (sv->state & SRV_STF_MAINTAIN) {
 				/* The server is really in maintenance, we can change the server state */
 				if (sv->track) {
 					/* If this server tracks the status of another one,
 					* we must restore the good status.
 					*/
-					if (sv->track->state & SRV_RUNNING) {
+					if (sv->track->state & SRV_STF_RUNNING) {
 						set_server_up(&sv->check);
 						sv->check.health = sv->check.rise;	/* up, but will fall down at first failure */
 					} else {
-						sv->state &= ~SRV_MAINTAIN;
+						sv->state &= ~SRV_STF_MAINTAIN;
 						sv->check.state &= ~CHK_ST_PAUSED;
 						set_server_down(&sv->check);
 					}
@@ -1782,9 +1782,9 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			if (!sv)
 				return 1;
 
-			if (! (sv->state & SRV_MAINTAIN)) {
+			if (! (sv->state & SRV_STF_MAINTAIN)) {
 				/* Not already in maintenance, we can change the server state */
-				sv->state |= SRV_MAINTAIN;
+				sv->state |= SRV_STF_MAINTAIN;
 				sv->check.state |= CHK_ST_PAUSED;
 				set_server_down(&sv->check);
 			}
@@ -2780,12 +2780,12 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 			"<i>no check</i>"
 		};
 
-		if ((sv->state & SRV_MAINTAIN) || (ref->state & SRV_MAINTAIN))
+		if ((sv->state & SRV_STF_MAINTAIN) || (ref->state & SRV_STF_MAINTAIN))
 			chunk_appendf(&trash, "<tr class=\"maintain\">");
 		else
 			chunk_appendf(&trash,
 			              "<tr class=\"%s%d\">",
-			              (sv->state & SRV_BACKUP) ? "backup" : "active", state);
+			              (sv->flags & SRV_F_BACKUP) ? "backup" : "active", state);
 
 		if ((px->cap & PR_CAP_BE) && px->srv && (appctx->ctx.stats.flags & STAT_ADMIN))
 			chunk_appendf(&trash,
@@ -2911,11 +2911,11 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 		/* status, lest check */
 		chunk_appendf(&trash, "<td class=ac>");
 
-		if (sv->state & SRV_MAINTAIN) {
+		if (sv->state & SRV_STF_MAINTAIN) {
 			chunk_appendf(&trash, "%s ", human_time(now.tv_sec - sv->last_change, 1));
 			chunk_appendf(&trash, "MAINT");
 		}
-		else if (ref != sv && ref->state & SRV_MAINTAIN) {
+		else if (ref != sv && ref->state & SRV_STF_MAINTAIN) {
 			chunk_appendf(&trash, "%s ", human_time(now.tv_sec - ref->last_change, 1));
 			chunk_appendf(&trash, "MAINT(via)");
 		}
@@ -2923,8 +2923,8 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 			chunk_appendf(&trash, "%s ", human_time(now.tv_sec - ref->last_change, 1));
 			chunk_appendf(&trash,
 			              srv_hlt_st[state],
-			              (ref->state & SRV_RUNNING) ? (ref->check.health - ref->check.rise + 1) : (ref->check.health),
-			              (ref->state & SRV_RUNNING) ? (ref->check.fall) : (ref->check.rise));
+			              (ref->state & SRV_STF_RUNNING) ? (ref->check.health - ref->check.rise + 1) : (ref->check.health),
+			              (ref->state & SRV_STF_RUNNING) ? (ref->check.fall) : (ref->check.rise));
 		}
 
 		if (sv->check.state & CHK_ST_ENABLED) {
@@ -2958,8 +2958,8 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 		              "<td class=ac>%s</td><td class=ac>%s</td>"
 		              "",
 		              (sv->eweight * px->lbprm.wmult + px->lbprm.wdiv - 1) / px->lbprm.wdiv,
-		              (sv->state & SRV_BACKUP) ? "-" : "Y",
-		              (sv->state & SRV_BACKUP) ? "Y" : "-");
+		              (sv->flags & SRV_F_BACKUP) ? "-" : "Y",
+		              (sv->flags & SRV_F_BACKUP) ? "Y" : "-");
 
 		/* check failures: unique, fatal, down time */
 		if (sv->check.state & CHK_ST_ENABLED) {
@@ -2976,7 +2976,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 			              ref->counters.down_trans, human_time(srv_downtime(sv), 1));
 		}
 		else if (sv != ref) {
-			if (sv->state & SRV_MAINTAIN)
+			if (sv->state & SRV_STF_MAINTAIN)
 				chunk_appendf(&trash, "<td class=ac colspan=3></td>");
 			else
 				chunk_appendf(&trash,
@@ -2987,7 +2987,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 			chunk_appendf(&trash, "<td colspan=3></td>");
 
 		/* throttle */
-		if ((sv->state & SRV_WARMINGUP) && !server_is_draining(sv))
+		if ((sv->state & SRV_STF_WARMINGUP) && !server_is_draining(sv))
 			chunk_appendf(&trash, "<td class=ac>%d %%</td></tr>\n", server_throttle_rate(sv));
 		else
 			chunk_appendf(&trash, "<td class=ac>-</td></tr>\n");
@@ -3030,23 +3030,23 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 		              sv->counters.retries, sv->counters.redispatches);
 
 		/* status */
-		if (sv->state & SRV_MAINTAIN)
+		if (sv->state & SRV_STF_MAINTAIN)
 			chunk_appendf(&trash, "MAINT,");
-		else if (ref != sv && ref->state & SRV_MAINTAIN)
+		else if (ref != sv && ref->state & SRV_STF_MAINTAIN)
 			chunk_appendf(&trash, "MAINT(via),");
 		else
 			chunk_appendf(&trash,
 			              srv_hlt_st[state],
-			              (ref->state & SRV_RUNNING) ? (ref->check.health - ref->check.rise + 1) : (ref->check.health),
-			              (ref->state & SRV_RUNNING) ? (ref->check.fall) : (ref->check.rise));
+			              (ref->state & SRV_STF_RUNNING) ? (ref->check.health - ref->check.rise + 1) : (ref->check.health),
+			              (ref->state & SRV_STF_RUNNING) ? (ref->check.fall) : (ref->check.rise));
 
 		chunk_appendf(&trash,
 		              /* weight, active, backup */
 		              "%d,%d,%d,"
 		              "",
 		              (sv->eweight * px->lbprm.wmult + px->lbprm.wdiv - 1) / px->lbprm.wdiv,
-		              (sv->state & SRV_BACKUP) ? 0 : 1,
-		              (sv->state & SRV_BACKUP) ? 1 : 0);
+		              (sv->flags & SRV_F_BACKUP) ? 0 : 1,
+		              (sv->flags & SRV_F_BACKUP) ? 1 : 0);
 
 		/* check failures: unique, fatal; last change, total downtime */
 		if (sv->check.state & CHK_ST_ENABLED)
@@ -3065,7 +3065,7 @@ static int stats_dump_sv_stats(struct stream_interface *si, struct proxy *px, in
 		              relative_pid, px->uuid, sv->puid);
 
 		/* throttle */
-		if ((sv->state & SRV_WARMINGUP) && !server_is_draining(sv))
+		if ((sv->state & SRV_STF_WARMINGUP) && !server_is_draining(sv))
 			chunk_appendf(&trash, "%d", server_throttle_rate(sv));
 
 		/* sessions: lbtot */
@@ -3621,7 +3621,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 			/* FIXME: produce some small strings for "UP/DOWN x/y &#xxxx;" */
 			if (!(svs->check.state & CHK_ST_ENABLED))
 				sv_state = 8;
-			else if (svs->state & SRV_RUNNING) {
+			else if (svs->state & SRV_STF_RUNNING) {
 				if (svs->check.health == svs->check.rise + svs->check.fall - 1)
 					sv_state = 3; /* UP */
 				else
@@ -3629,7 +3629,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 
 				if (server_is_draining(sv))
 					sv_state += 4;
-				else if (svs->state & SRV_GOINGDOWN)
+				else if (svs->state & SRV_STF_GOINGDOWN)
 					sv_state += 2;
 			}
 			else
@@ -3638,7 +3638,7 @@ static int stats_dump_proxy_to_buffer(struct stream_interface *si, struct proxy
 				else
 					sv_state = 0; /* DOWN */
 
-			if (((sv_state == 0) || (sv->state & SRV_MAINTAIN)) && (appctx->ctx.stats.flags & STAT_HIDE_DOWN)) {
+			if (((sv_state == 0) || (sv->state & SRV_STF_MAINTAIN)) && (appctx->ctx.stats.flags & STAT_HIDE_DOWN)) {
 				/* do not report servers which are DOWN */
 				appctx->ctx.stats.sv = sv->next;
 				continue;
@@ -4249,9 +4249,9 @@ static int stats_process_http_post(struct stream_interface *si)
 				else if ((sv = findserver(px, value)) != NULL) {
 					switch (action) {
 					case ST_ADM_ACTION_DISABLE:
-						if ((px->state != PR_STSTOPPED) && !(sv->state & SRV_MAINTAIN)) {
+						if ((px->state != PR_STSTOPPED) && !(sv->state & SRV_STF_MAINTAIN)) {
 							/* Not already in maintenance, we can change the server state */
-							sv->state |= SRV_MAINTAIN;
+							sv->state |= SRV_STF_MAINTAIN;
 							sv->check.state |= CHK_ST_PAUSED;
 							set_server_down(&sv->check);
 							altered_servers++;
@@ -4259,17 +4259,17 @@ static int stats_process_http_post(struct stream_interface *si)
 						}
 						break;
 					case ST_ADM_ACTION_ENABLE:
-						if ((px->state != PR_STSTOPPED) && (sv->state & SRV_MAINTAIN)) {
+						if ((px->state != PR_STSTOPPED) && (sv->state & SRV_STF_MAINTAIN)) {
 							/* Already in maintenance, we can change the server state.
 							 * If this server tracks the status of another one,
 							 * we must restore the good status.
 							 */
-							if (!sv->track || (sv->track->state & SRV_RUNNING)) {
+							if (!sv->track || (sv->track->state & SRV_STF_RUNNING)) {
 								set_server_up(&sv->check);
 								sv->check.health = sv->check.rise;	/* up, but will fall down at first failure */
 							}
 							else {
-								sv->state &= ~SRV_MAINTAIN;
+								sv->state &= ~SRV_STF_MAINTAIN;
 								sv->check.state &= ~CHK_ST_PAUSED;
 								set_server_down(&sv->check);
 							}
diff --git a/src/haproxy.c b/src/haproxy.c
index 060a155..ca74e4e 100644
--- a/src/haproxy.c
+++ b/src/haproxy.c
@@ -449,7 +449,7 @@ void sig_dump_state(struct sig_handler *sh)
 			chunk_printf(&trash,
 			             "SIGHUP: Server %s/%s is %s. Conn: %d act, %d pend, %lld tot.",
 			             p->id, s->id,
-			             (s->state & SRV_RUNNING) ? "UP" : "DOWN",
+			             (s->state & SRV_STF_RUNNING) ? "UP" : "DOWN",
 			             s->cur_sess, s->nbpend, s->counters.cum_sess);
 			Warning("%s\n", trash.str);
 			send_log(p, LOG_NOTICE, "%s\n", trash.str);
diff --git a/src/lb_chash.c b/src/lb_chash.c
index 3563cff..ee1dc52 100644
--- a/src/lb_chash.c
+++ b/src/lb_chash.c
@@ -108,7 +108,7 @@ static void chash_set_server_status_down(struct server *srv)
 		/* server was already down */
 		goto out_update_backend;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck -= srv->prev_eweight;
 		p->srv_bck--;
 
@@ -120,7 +120,7 @@ static void chash_set_server_status_down(struct server *srv)
 			do {
 				srv2 = srv2->next;
 			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
+				 !((srv2->flags & SRV_F_BACKUP) &&
 				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
@@ -159,7 +159,7 @@ static void chash_set_server_status_up(struct server *srv)
 		/* server was already up */
 		goto out_update_backend;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck += srv->eweight;
 		p->srv_bck++;
 
@@ -232,7 +232,7 @@ static void chash_update_server_weight(struct server *srv)
 	/* only adjust the server's presence in the tree */
 	chash_queue_dequeue_srv(srv);
 
-	if (srv->state & SRV_BACKUP)
+	if (srv->flags & SRV_F_BACKUP)
 		p->lbprm.tot_wbck += srv->eweight - srv->prev_eweight;
 	else
 		p->lbprm.tot_wact += srv->eweight - srv->prev_eweight;
@@ -388,7 +388,7 @@ void chash_init_server_tree(struct proxy *p)
 
 	/* queue active and backup servers in two distinct groups */
 	for (srv = p->srv; srv; srv = srv->next) {
-		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.chash.bck : &p->lbprm.chash.act;
+		srv->lb_tree = (srv->flags & SRV_F_BACKUP) ? &p->lbprm.chash.bck : &p->lbprm.chash.act;
 		srv->lb_nodes_tot = srv->uweight * BE_WEIGHT_SCALE;
 		srv->lb_nodes_now = 0;
 		srv->lb_nodes = (struct tree_occ *)calloc(srv->lb_nodes_tot, sizeof(struct tree_occ));
diff --git a/src/lb_fas.c b/src/lb_fas.c
index 7bd3d05..6027dac 100644
--- a/src/lb_fas.c
+++ b/src/lb_fas.c
@@ -87,7 +87,7 @@ static void fas_set_server_status_down(struct server *srv)
 		/* server was already down */
 		goto out_update_backend;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck -= srv->prev_eweight;
 		p->srv_bck--;
 
@@ -99,7 +99,7 @@ static void fas_set_server_status_down(struct server *srv)
 			do {
 				srv2 = srv2->next;
 			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
+				 !((srv2->flags & SRV_F_BACKUP) &&
 				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
@@ -139,7 +139,7 @@ static void fas_set_server_status_up(struct server *srv)
 		/* server was already up */
 		goto out_update_backend;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		srv->lb_tree = &p->lbprm.fas.bck;
 		p->lbprm.tot_wbck += srv->eweight;
 		p->srv_bck++;
@@ -214,7 +214,7 @@ static void fas_update_server_weight(struct server *srv)
 	if (srv->lb_tree)
 		fas_dequeue_srv(srv);
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck += srv->eweight - srv->prev_eweight;
 		srv->lb_tree = &p->lbprm.fas.bck;
 	} else {
@@ -259,7 +259,7 @@ void fas_init_server_tree(struct proxy *p)
 	for (srv = p->srv; srv; srv = srv->next) {
 		if (!srv_is_usable(srv))
 			continue;
-		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.fas.bck : &p->lbprm.fas.act;
+		srv->lb_tree = (srv->flags & SRV_F_BACKUP) ? &p->lbprm.fas.bck : &p->lbprm.fas.act;
 		fas_queue_srv(srv);
 	}
 }
diff --git a/src/lb_fwlc.c b/src/lb_fwlc.c
index 9fb57ac..49be24f 100644
--- a/src/lb_fwlc.c
+++ b/src/lb_fwlc.c
@@ -79,7 +79,7 @@ static void fwlc_set_server_status_down(struct server *srv)
 		/* server was already down */
 		goto out_update_backend;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck -= srv->prev_eweight;
 		p->srv_bck--;
 
@@ -91,7 +91,7 @@ static void fwlc_set_server_status_down(struct server *srv)
 			do {
 				srv2 = srv2->next;
 			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
+				 !((srv2->flags & SRV_F_BACKUP) &&
 				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
@@ -131,7 +131,7 @@ static void fwlc_set_server_status_up(struct server *srv)
 		/* server was already up */
 		goto out_update_backend;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		srv->lb_tree = &p->lbprm.fwlc.bck;
 		p->lbprm.tot_wbck += srv->eweight;
 		p->srv_bck++;
@@ -206,7 +206,7 @@ static void fwlc_update_server_weight(struct server *srv)
 	if (srv->lb_tree)
 		fwlc_dequeue_srv(srv);
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck += srv->eweight - srv->prev_eweight;
 		srv->lb_tree = &p->lbprm.fwlc.bck;
 	} else {
@@ -251,7 +251,7 @@ void fwlc_init_server_tree(struct proxy *p)
 	for (srv = p->srv; srv; srv = srv->next) {
 		if (!srv_is_usable(srv))
 			continue;
-		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.fwlc.bck : &p->lbprm.fwlc.act;
+		srv->lb_tree = (srv->flags & SRV_F_BACKUP) ? &p->lbprm.fwlc.bck : &p->lbprm.fwlc.act;
 		fwlc_queue_srv(srv);
 	}
 }
diff --git a/src/lb_fwrr.c b/src/lb_fwrr.c
index f15de23..78be7ff 100644
--- a/src/lb_fwrr.c
+++ b/src/lb_fwrr.c
@@ -49,10 +49,10 @@ static void fwrr_set_server_status_down(struct server *srv)
 		/* server was already down */
 		goto out_update_backend;
 
-	grp = (srv->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
+	grp = (srv->flags & SRV_F_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
 	grp->next_weight -= srv->prev_eweight;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck = p->lbprm.fwrr.bck.next_weight;
 		p->srv_bck--;
 
@@ -64,7 +64,7 @@ static void fwrr_set_server_status_down(struct server *srv)
 			do {
 				srv2 = srv2->next;
 			} while (srv2 &&
-				 !((srv2->state & SRV_BACKUP) &&
+				 !((srv2->flags & SRV_F_BACKUP) &&
 				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
@@ -105,10 +105,10 @@ static void fwrr_set_server_status_up(struct server *srv)
 		/* server was already up */
 		goto out_update_backend;
 
-	grp = (srv->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
+	grp = (srv->flags & SRV_F_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
 	grp->next_weight += srv->eweight;
 
-	if (srv->state & SRV_BACKUP) {
+	if (srv->flags & SRV_F_BACKUP) {
 		p->lbprm.tot_wbck = p->lbprm.fwrr.bck.next_weight;
 		p->srv_bck++;
 
@@ -181,7 +181,7 @@ static void fwrr_update_server_weight(struct server *srv)
 		return;
 	}
 
-	grp = (srv->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
+	grp = (srv->flags & SRV_F_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
 	grp->next_weight = grp->next_weight - srv->prev_eweight + srv->eweight;
 
 	p->lbprm.tot_wact = p->lbprm.fwrr.act.next_weight;
@@ -292,7 +292,7 @@ void fwrr_init_server_groups(struct proxy *p)
 	for (srv = p->srv; srv; srv = srv->next) {
 		if (!srv_is_usable(srv))
 			continue;
-		fwrr_queue_by_weight((srv->state & SRV_BACKUP) ?
+		fwrr_queue_by_weight((srv->flags & SRV_F_BACKUP) ?
 				p->lbprm.fwrr.bck.init :
 				p->lbprm.fwrr.act.init,
 				srv);
@@ -314,7 +314,7 @@ static void fwrr_queue_srv(struct server *s)
 	struct proxy *p = s->proxy;
 	struct fwrr_group *grp;
 
-	grp = (s->state & SRV_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
+	grp = (s->flags & SRV_F_BACKUP) ? &p->lbprm.fwrr.bck : &p->lbprm.fwrr.act;
 	
 	/* Delay everything which does not fit into the window and everything
 	 * which does not fit into the theorical new window.
@@ -355,7 +355,7 @@ static inline void fwrr_get_srv_init(struct server *s)
 /* prepares a server when extracting it from the "next" tree */
 static inline void fwrr_get_srv_next(struct server *s)
 {
-	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?
+	struct fwrr_group *grp = (s->flags & SRV_F_BACKUP) ?
 		&s->proxy->lbprm.fwrr.bck :
 		&s->proxy->lbprm.fwrr.act;
 
@@ -365,7 +365,7 @@ static inline void fwrr_get_srv_next(struct server *s)
 /* prepares a server when it was marked down */
 static inline void fwrr_get_srv_down(struct server *s)
 {
-	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?
+	struct fwrr_group *grp = (s->flags & SRV_F_BACKUP) ?
 		&s->proxy->lbprm.fwrr.bck :
 		&s->proxy->lbprm.fwrr.act;
 
@@ -376,7 +376,7 @@ static inline void fwrr_get_srv_down(struct server *s)
 static void fwrr_get_srv(struct server *s)
 {
 	struct proxy *p = s->proxy;
-	struct fwrr_group *grp = (s->state & SRV_BACKUP) ?
+	struct fwrr_group *grp = (s->flags & SRV_F_BACKUP) ?
 		&p->lbprm.fwrr.bck :
 		&p->lbprm.fwrr.act;
 
diff --git a/src/lb_map.c b/src/lb_map.c
index a108bdb..24ae4ec 100644
--- a/src/lb_map.c
+++ b/src/lb_map.c
@@ -82,9 +82,9 @@ void recalc_server_map(struct proxy *px)
 
 	/* here we *know* that we have some servers */
 	if (px->srv_act)
-		flag = SRV_RUNNING;
+		flag = 0;
 	else
-		flag = SRV_RUNNING | SRV_BACKUP;
+		flag = SRV_F_BACKUP;
 
 	/* this algorithm gives priority to the first server, which means that
 	 * it will respect the declaration order for equivalent weights, and
@@ -100,8 +100,8 @@ void recalc_server_map(struct proxy *px)
 		best = NULL;
 		for (cur = px->srv; cur; cur = cur->next) {
 			if (cur->eweight &&
-			    flag == (cur->state &
-				     (SRV_RUNNING | SRV_GOINGDOWN | SRV_BACKUP))) {
+			    (cur->flags & SRV_F_BACKUP) == flag &&
+			    (cur->state & (SRV_STF_RUNNING | SRV_STF_GOINGDOWN)) == SRV_STF_RUNNING) {
 				int v;
 
 				/* If we are forced to return only one server, we don't want to
@@ -179,7 +179,7 @@ void init_server_map(struct proxy *p)
 		srv->eweight = (srv->uweight * p->lbprm.wdiv + p->lbprm.wmult - 1) / p->lbprm.wmult;
 		srv_lb_commit_status(srv);
 
-		if (srv->state & SRV_BACKUP)
+		if (srv->flags & SRV_F_BACKUP)
 			bck += srv->eweight;
 		else
 			act += srv->eweight;
diff --git a/src/proto_http.c b/src/proto_http.c
index 1b96e3f..4892b8b 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -7069,12 +7069,12 @@ void manage_client_side_appsession(struct session *s, const char *buf, int len)
 
 			while (srv) {
 				if (strcmp(srv->id, asession->serverid) == 0) {
-					if ((srv->state & SRV_RUNNING) ||
+					if ((srv->state & SRV_STF_RUNNING) ||
 					    (s->be->options & PR_O_PERSIST) ||
 					    (s->flags & SN_FORCE_PRST)) {
 						/* we found the server and it's usable */
 						txn->flags &= ~TX_CK_MASK;
-						txn->flags |= (srv->state & SRV_RUNNING) ? TX_CK_VALID : TX_CK_DOWN;
+						txn->flags |= (srv->state & SRV_STF_RUNNING) ? TX_CK_VALID : TX_CK_DOWN;
 						s->flags |= SN_DIRECT | SN_ASSIGNED;
 						s->target = &srv->obj_type;
 
@@ -7479,12 +7479,12 @@ void manage_client_side_cookies(struct session *s, struct channel *req)
 				while (srv) {
 					if (srv->cookie && (srv->cklen == delim - val_beg) &&
 					    !memcmp(val_beg, srv->cookie, delim - val_beg)) {
-						if ((srv->state & SRV_RUNNING) ||
+						if ((srv->state & SRV_STF_RUNNING) ||
 						    (s->be->options & PR_O_PERSIST) ||
 						    (s->flags & SN_FORCE_PRST)) {
 							/* we found the server and we can use it */
 							txn->flags &= ~TX_CK_MASK;
-							txn->flags |= (srv->state & SRV_RUNNING) ? TX_CK_VALID : TX_CK_DOWN;
+							txn->flags |= (srv->state & SRV_STF_RUNNING) ? TX_CK_VALID : TX_CK_DOWN;
 							s->flags |= SN_DIRECT | SN_ASSIGNED;
 							s->target = &srv->obj_type;
 							break;
diff --git a/src/queue.c b/src/queue.c
index 006941b..8fd1f08 100644
--- a/src/queue.c
+++ b/src/queue.c
@@ -50,7 +50,7 @@ unsigned int srv_dynamic_maxconn(const struct server *s)
 	else max = MAX(s->minconn,
 		       s->proxy->beconn * s->maxconn / s->proxy->fullconn);
 
-	if ((s->state & SRV_WARMINGUP) &&
+	if ((s->state & SRV_STF_WARMINGUP) &&
 	    now.tv_sec < s->last_change + s->slowstart &&
 	    now.tv_sec >= s->last_change) {
 		unsigned int ratio;
diff --git a/src/server.c b/src/server.c
index e0b200d..dc0883e 100644
--- a/src/server.c
+++ b/src/server.c
@@ -32,7 +32,7 @@ static struct srv_kw_list srv_keywords = {
 
 int srv_downtime(const struct server *s)
 {
-	if ((s->state & SRV_RUNNING) && s->last_change < now.tv_sec)		// ignore negative time
+	if ((s->state & SRV_STF_RUNNING) && s->last_change < now.tv_sec)		// ignore negative time
 		return s->down_time;
 
 	return now.tv_sec - s->last_change + s->down_time;
@@ -53,7 +53,7 @@ int srv_getinter(const struct check *check)
 	if ((check->state & CHK_ST_CONFIGURED) && (check->health == check->rise + check->fall - 1))
 		return check->inter;
 
-	if (!(s->state & SRV_RUNNING) && check->health == 0)
+	if (!(s->state & SRV_STF_RUNNING) && check->health == 0)
 		return (check->downinter)?(check->downinter):(check->inter);
 
 	return (check->fastinter)?(check->fastinter):(check->inter);
@@ -185,13 +185,13 @@ void server_recalc_eweight(struct server *sv)
 
 	if (now.tv_sec < sv->last_change || now.tv_sec >= sv->last_change + sv->slowstart) {
 		/* go to full throttle if the slowstart interval is reached */
-		sv->state &= ~SRV_WARMINGUP;
+		sv->state &= ~SRV_STF_WARMINGUP;
 	}
 
 	/* We must take care of not pushing the server to full throttle during slow starts.
 	 * It must also start immediately, at least at the minimal step when leaving maintenance.
 	 */
-	if ((sv->state & SRV_WARMINGUP) && (px->lbprm.algo & BE_LB_PROP_DYN))
+	if ((sv->state & SRV_STF_WARMINGUP) && (px->lbprm.algo & BE_LB_PROP_DYN))
 		w = (px->lbprm.wdiv * (now.tv_sec - sv->last_change) + sv->slowstart) / sv->slowstart;
 	else
 		w = px->lbprm.wdiv;
@@ -345,7 +345,8 @@ int parse_server(const char *file, int linenum, char **args, struct proxy *curpr
 			LIST_INIT(&newsrv->pendconns);
 			do_check = 0;
 			do_agent = 0;
-			newsrv->state = SRV_RUNNING; /* early server setup */
+			newsrv->flags = 0;
+			newsrv->state = SRV_STF_RUNNING; /* early server setup */
 			newsrv->last_change = now.tv_sec;
 			newsrv->id = strdup(args[1]);
 
@@ -373,7 +374,7 @@ int parse_server(const char *file, int linenum, char **args, struct proxy *curpr
 
 			if (!port1 || !port2) {
 				/* no port specified, +offset, -offset */
-				newsrv->state |= SRV_MAPPORTS;
+				newsrv->flags |= SRV_F_MAPPORTS;
 			}
 			else if (port1 != port2) {
 				/* port range */
@@ -605,11 +606,11 @@ int parse_server(const char *file, int linenum, char **args, struct proxy *curpr
 				cur_arg += 2;
 			}
 			else if (!defsrv && !strcmp(args[cur_arg], "backup")) {
-				newsrv->state |= SRV_BACKUP;
+				newsrv->flags |= SRV_F_BACKUP;
 				cur_arg ++;
 			}
 			else if (!defsrv && !strcmp(args[cur_arg], "non-stick")) {
-				newsrv->state |= SRV_NON_STICK;
+				newsrv->flags |= SRV_F_NON_STICK;
 				cur_arg ++;
 			}
 			else if (!defsrv && !strcmp(args[cur_arg], "send-proxy")) {
@@ -679,8 +680,8 @@ int parse_server(const char *file, int linenum, char **args, struct proxy *curpr
 				cur_arg += 1;
 			}
 			else if (!defsrv && !strcmp(args[cur_arg], "disabled")) {
-				newsrv->state |= SRV_MAINTAIN;
-				newsrv->state &= ~SRV_RUNNING;
+				newsrv->state |= SRV_STF_MAINTAIN;
+				newsrv->state &= ~SRV_STF_RUNNING;
 				newsrv->check.state |= CHK_ST_PAUSED;
 				newsrv->check.health = 0;
 				newsrv->agent.health = 0;
@@ -1138,7 +1139,7 @@ int parse_server(const char *file, int linenum, char **args, struct proxy *curpr
 		}
 
 		if (!defsrv) {
-			if (newsrv->state & SRV_BACKUP)
+			if (newsrv->flags & SRV_F_BACKUP)
 				curproxy->srv_bck++;
 			else
 				curproxy->srv_act++;
diff --git a/src/session.c b/src/session.c
index d2c2850..336274c 100644
--- a/src/session.c
+++ b/src/session.c
@@ -1375,7 +1375,7 @@ static int process_server_rules(struct session *s, struct channel *req, int an_b
 			if (ret) {
 				struct server *srv = rule->srv.ptr;
 
-				if ((srv->state & SRV_RUNNING) ||
+				if ((srv->state & SRV_STF_RUNNING) ||
 				    (px->options & PR_O_PERSIST) ||
 				    (s->flags & SN_FORCE_PRST)) {
 					s->flags |= SN_DIRECT | SN_ASSIGNED;
@@ -1460,7 +1460,7 @@ static int process_sticking_rules(struct session *s, struct channel *req, int an
 							struct server *srv;
 
 							srv = container_of(node, struct server, conf.id);
-							if ((srv->state & SRV_RUNNING) ||
+							if ((srv->state & SRV_STF_RUNNING) ||
 							    (px->options & PR_O_PERSIST) ||
 							    (s->flags & SN_FORCE_PRST)) {
 								s->flags |= SN_DIRECT | SN_ASSIGNED;
@@ -1565,7 +1565,7 @@ static int process_store_rules(struct session *s, struct channel *rep, int an_bi
 		struct stksess *ts;
 		void *ptr;
 
-		if (objt_server(s->target) && objt_server(s->target)->state & SRV_NON_STICK) {
+		if (objt_server(s->target) && objt_server(s->target)->flags & SRV_F_NON_STICK) {
 			stksess_free(s->store[i].table, s->store[i].ts);
 			s->store[i].ts = NULL;
 			continue;
-- 
1.8.3.2

