From a631fc8de8786fee15c83b33aae81dabe3a5f1a3 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Sat, 26 Apr 2014 23:33:51 +0200
Subject: [PATCH 02/23] BUG/MAJOR: patterns: -i and -n are ignored for inlined
 patterns

These flags are only passed to pattern_read_from_file() which
loads the patterns from a file. The functions used to parse the
patterns from the current line do not provide the means to pass
the pattern flags so they're lost.

This issue was introduced in dev23 with the major pattern rework,
and was reported by Graham Morley. No backport is needed.
---
 include/proto/pattern.h | 2 +-
 src/acl.c               | 2 +-
 src/dumpstats.c         | 4 ++--
 src/pattern.c           | 4 ++--
 src/proto_http.c        | 8 ++++----
 5 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/include/proto/pattern.h b/include/proto/pattern.h
index e6ceba8..22da6d5 100644
--- a/include/proto/pattern.h
+++ b/include/proto/pattern.h
@@ -183,7 +183,7 @@ struct pat_ref *pat_ref_new(const char *reference, const char *display, unsigned
 struct pat_ref *pat_ref_newid(int unique_id, const char *display, unsigned int flags);
 struct pat_ref_elt *pat_ref_find_elt(struct pat_ref *ref, const char *key);
 int pat_ref_append(struct pat_ref *ref, char *pattern, char *sample, int line);
-int pat_ref_add(struct pat_ref *ref, const char *pattern, const char *sample, char **err);
+int pat_ref_add(struct pat_ref *ref, const char *pattern, const char *sample, int patflags, char **err);
 int pat_ref_set(struct pat_ref *ref, const char *pattern, const char *sample, char **err);
 int pat_ref_set_by_id(struct pat_ref *ref, struct pat_ref_elt *refelt, const char *value, char **err);
 int pat_ref_delete(struct pat_ref *ref, const char *key);
diff --git a/src/acl.c b/src/acl.c
index 29b158f..93cf31c 100644
--- a/src/acl.c
+++ b/src/acl.c
@@ -659,7 +659,7 @@ struct acl_expr *parse_acl_expr(const char **args, char **err, struct arg_list *
 		/* Add sample to the reference, and try to compile it fior each pattern
 		 * using this value.
 		 */
-		if (!pat_ref_add(ref, arg, NULL, err))
+		if (!pat_ref_add(ref, arg, NULL, patflags, err))
 			goto out_free_expr;
 		args++;
 	}
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 5f28e1c..7cf4d84 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -2055,9 +2055,9 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			/* Add value. */
 			err = NULL;
 			if (appctx->ctx.map.display_flags == PAT_REF_MAP)
-				ret = pat_ref_add(appctx->ctx.map.ref, args[3], args[4], &err);
+				ret = pat_ref_add(appctx->ctx.map.ref, args[3], args[4], 0, &err);
 			else
-				ret = pat_ref_add(appctx->ctx.map.ref, args[3], NULL, &err);
+				ret = pat_ref_add(appctx->ctx.map.ref, args[3], NULL, 0, &err);
 			if (!ret) {
 				if (err)
 					memprintf(&err, "%s.\n", err);
diff --git a/src/pattern.c b/src/pattern.c
index 5ebb5ce..e741b20 100644
--- a/src/pattern.c
+++ b/src/pattern.c
@@ -1697,7 +1697,7 @@ int pat_ref_push(struct pat_ref_elt *elt, struct pattern_expr *expr,
  */
 int pat_ref_add(struct pat_ref *ref,
                 const char *pattern, const char *sample,
-                char **err)
+                int patflags, char **err)
 {
 	struct pat_ref_elt *elt;
 	struct pattern_expr *expr;
@@ -1732,7 +1732,7 @@ int pat_ref_add(struct pat_ref *ref,
 	LIST_ADDQ(&ref->head, &elt->list);
 
 	list_for_each_entry(expr, &ref->pat, list) {
-		if (!pat_ref_push(elt, expr, 0, err)) {
+		if (!pat_ref_push(elt, expr, patflags, err)) {
 			/* If the insertion fails, try to delete all the added entries. */
 			pat_ref_delete_by_id(ref, elt);
 			return 0;
diff --git a/src/proto_http.c b/src/proto_http.c
index 90b73da..b7f6edf 100644
--- a/src/proto_http.c
+++ b/src/proto_http.c
@@ -3260,7 +3260,7 @@ http_req_get_intercept_rule(struct proxy *px, struct list *rules, struct session
 			/* perform update */
 			/* add entry only if it does not already exist */
 			if (pat_ref_find_elt(ref, key) == NULL)
-				pat_ref_add(ref, key, NULL, NULL);
+				pat_ref_add(ref, key, NULL, 0, NULL);
 
 			break;
 			}
@@ -3295,7 +3295,7 @@ http_req_get_intercept_rule(struct proxy *px, struct list *rules, struct session
 				pat_ref_set(ref, key, value, NULL);
 			else
 				/* insert a new entry */
-				pat_ref_add(ref, key, value, NULL);
+				pat_ref_add(ref, key, value, 0, NULL);
 
 			break;
 			}
@@ -3441,7 +3441,7 @@ http_res_get_intercept_rule(struct proxy *px, struct list *rules, struct session
 			/* perform update */
 			/* check if the entry already exists */
 			if (pat_ref_find_elt(ref, key) == NULL)
-				pat_ref_add(ref, key, NULL, NULL);
+				pat_ref_add(ref, key, NULL, 0, NULL);
 
 			break;
 			}
@@ -3476,7 +3476,7 @@ http_res_get_intercept_rule(struct proxy *px, struct list *rules, struct session
 				pat_ref_set(ref, key, value, NULL);
 			else
 				/* insert a new entry */
-				pat_ref_add(ref, key, value, NULL);
+				pat_ref_add(ref, key, value, 0, NULL);
 
 			break;
 			}
-- 
1.8.3.2

