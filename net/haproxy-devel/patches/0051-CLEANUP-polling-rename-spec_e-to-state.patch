From 69a41fa8a397ec9608ce448e2cef4c7480d18433 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Mon, 20 Jan 2014 11:02:59 +0100
Subject: [PATCH 51/69] CLEANUP: polling: rename "spec_e" to "state"

We're completely changing the way FDs will be polled. First, let's fix
a few field names which become confusing. "spec_e" was used to store a
speculative I/O event state. Now we'll store the whole R/W states for
the FD there.
---
 include/proto/fd.h | 18 +++++++++---------
 include/types/fd.h |  4 ++--
 src/dumpstats.c    |  4 ++--
 src/ev_epoll.c     | 12 ++++++------
 src/ev_kqueue.c    | 10 +++++-----
 src/ev_poll.c      |  6 +++---
 src/ev_select.c    |  6 +++---
 src/fd.c           |  6 +++---
 8 files changed, 33 insertions(+), 33 deletions(-)

diff --git a/include/proto/fd.h b/include/proto/fd.h
index 7fe616e..a67a320 100644
--- a/include/proto/fd.h
+++ b/include/proto/fd.h
@@ -131,7 +131,7 @@ static inline void release_spec_entry(int fd)
  */
 static inline int fd_ev_is_set(const int fd, int dir)
 {
-	return ((unsigned)fdtab[fd].spec_e >> dir) & FD_EV_STATUS;
+	return ((unsigned)fdtab[fd].state >> dir) & FD_EV_STATUS;
 }
 
 /* Disable processing of events on fd <fd> for direction <dir>. Note: this
@@ -139,10 +139,10 @@ static inline int fd_ev_is_set(const int fd, int dir)
  */
 static inline void fd_ev_clr(const int fd, int dir)
 {
-	unsigned int i = ((unsigned int)fdtab[fd].spec_e) & (FD_EV_STATUS << dir);
+	unsigned int i = ((unsigned int)fdtab[fd].state) & (FD_EV_STATUS << dir);
 	if (i == 0)
 		return; /* already disabled */
-	fdtab[fd].spec_e ^= i;
+	fdtab[fd].state ^= i;
 	updt_fd(fd); /* need an update entry to change the state */
 }
 
@@ -151,10 +151,10 @@ static inline void fd_ev_clr(const int fd, int dir)
  */
 static inline void fd_ev_wai(const int fd, int dir)
 {
-	unsigned int i = ((unsigned int)fdtab[fd].spec_e) & (FD_EV_STATUS << dir);
+	unsigned int i = ((unsigned int)fdtab[fd].state) & (FD_EV_STATUS << dir);
 	if (i == (FD_EV_POLLED << dir))
 		return; /* already in desired state */
-	fdtab[fd].spec_e ^= i ^ (FD_EV_POLLED << dir);
+	fdtab[fd].state ^= i ^ (FD_EV_POLLED << dir);
 	updt_fd(fd); /* need an update entry to change the state */
 }
 
@@ -163,7 +163,7 @@ static inline void fd_ev_wai(const int fd, int dir)
  */
 static inline void fd_ev_set(int fd, int dir)
 {
-	unsigned int i = ((unsigned int)fdtab[fd].spec_e) & (FD_EV_STATUS << dir);
+	unsigned int i = ((unsigned int)fdtab[fd].state) & (FD_EV_STATUS << dir);
 
 	/* note that we don't care about disabling the polled state when
 	 * enabling the active state, since it brings no benefit but costs
@@ -171,17 +171,17 @@ static inline void fd_ev_set(int fd, int dir)
 	 */
 	if (i & (FD_EV_ACTIVE << dir))
 		return; /* already in desired state */
-	fdtab[fd].spec_e |= (FD_EV_ACTIVE << dir);
+	fdtab[fd].state |= (FD_EV_ACTIVE << dir);
 	updt_fd(fd); /* need an update entry to change the state */
 }
 
 /* Disable processing of events on fd <fd> for both directions. */
 static inline void fd_ev_rem(const int fd)
 {
-	unsigned int i = ((unsigned int)fdtab[fd].spec_e) & FD_EV_CURR_MASK;
+	unsigned int i = ((unsigned int)fdtab[fd].state) & FD_EV_CURR_MASK;
 	if (i == 0)
 		return; /* already disabled */
-	fdtab[fd].spec_e ^= i;
+	fdtab[fd].state ^= i;
 	updt_fd(fd); /* need an update entry to change the state */
 }
 
diff --git a/include/types/fd.h b/include/types/fd.h
index 701edfc..23550cb 100644
--- a/include/types/fd.h
+++ b/include/types/fd.h
@@ -46,7 +46,7 @@ enum {
 #define FD_POLL_STICKY  (FD_POLL_ERR | FD_POLL_HUP)
 
 /* Event state for an FD in each direction, as found in the 4 lower bits of
- * fdtab[].spec_e, and in the 4 next bits.
+ * fdtab[].state, and in the 4 next bits.
  */
 #define FD_EV_ACTIVE    1U
 #define FD_EV_POLLED    4U
@@ -70,7 +70,7 @@ struct fdtab {
 	int (*iocb)(int fd);                 /* I/O handler, returns FD_WAIT_* */
 	void *owner;                         /* the connection or listener associated with this fd, NULL if closed */
 	unsigned int  spec_p;                /* speculative polling: position in spec list+1. 0=not in list. */
-	unsigned char spec_e;                /* speculative polling: read and write events status. 4 bits */
+	unsigned char state;                 /* FD state for read and write directions */
 	unsigned char ev;                    /* event seen in return of poll() : FD_POLL_* */
 	unsigned char new:1;                 /* 1 if this fd has just been created */
 	unsigned char updated:1;             /* 1 if this fd is already in the update list */
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 219b81f..f861650 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -4528,7 +4528,7 @@ static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct se
 			              "      flags=0x%08x fd=%d fd_spec_e=%02x fd_spec_p=%d updt=%d\n",
 			              conn->flags,
 			              conn->t.sock.fd,
-			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].spec_e : 0,
+			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].state : 0,
 			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].spec_p : 0,
 			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].updated : 0);
 		}
@@ -4556,7 +4556,7 @@ static int stats_dump_full_sess_to_buffer(struct stream_interface *si, struct se
 			              "      flags=0x%08x fd=%d fd_spec_e=%02x fd_spec_p=%d updt=%d\n",
 			              conn->flags,
 			              conn->t.sock.fd,
-			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].spec_e : 0,
+			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].state : 0,
 			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].spec_p : 0,
 			              conn->t.sock.fd >= 0 ? fdtab[conn->t.sock.fd].updated : 0);
 		}
diff --git a/src/ev_epoll.c b/src/ev_epoll.c
index 18abb10..ba0025b 100644
--- a/src/ev_epoll.c
+++ b/src/ev_epoll.c
@@ -59,8 +59,8 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	/* first, scan the update list to find changes */
 	for (updt_idx = 0; updt_idx < fd_nbupdt; updt_idx++) {
 		fd = fd_updt[updt_idx];
-		en = fdtab[fd].spec_e & 15;  /* new events */
-		eo = fdtab[fd].spec_e >> 4;  /* previous events */
+		en = fdtab[fd].state & 15;  /* new events */
+		eo = fdtab[fd].state >> 4;  /* previous events */
 
 		if (fdtab[fd].owner && (eo ^ en)) {
 			if ((eo ^ en) & FD_EV_POLLED_RW) {
@@ -90,7 +90,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 				epoll_ctl(epoll_fd, opcode, fd, &ev);
 			}
 
-			fdtab[fd].spec_e = (en << 4) + en;  /* save new events */
+			fdtab[fd].state = (en << 4) + en;  /* save new events */
 
 			if (!(en & FD_EV_ACTIVE_RW)) {
 				/* This fd doesn't use any active entry anymore, we can
@@ -213,10 +213,10 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 				fdtab[fd].new = 0;
 				fdtab[fd].ev &= FD_POLL_STICKY;
 
-				if ((fdtab[fd].spec_e & FD_EV_STATUS_R) == FD_EV_ACTIVE_R)
+				if ((fdtab[fd].state & FD_EV_STATUS_R) == FD_EV_ACTIVE_R)
 					fdtab[fd].ev |= FD_POLL_IN;
 
-				if ((fdtab[fd].spec_e & FD_EV_STATUS_W) == FD_EV_ACTIVE_W)
+				if ((fdtab[fd].state & FD_EV_STATUS_W) == FD_EV_ACTIVE_W)
 					fdtab[fd].ev |= FD_POLL_OUT;
 
 				if (fdtab[fd].ev && fdtab[fd].iocb && fdtab[fd].owner)
@@ -225,7 +225,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 				/* we can remove this update entry if it's the last one and is
 				 * unused, otherwise we don't touch anything.
 				 */
-				if (new_updt == fd_nbupdt && fdtab[fd].spec_e == 0) {
+				if (new_updt == fd_nbupdt && fdtab[fd].state == 0) {
 					fdtab[fd].updated = 0;
 					fd_nbupdt--;
 				}
diff --git a/src/ev_kqueue.c b/src/ev_kqueue.c
index 2142132..ca14eeb 100644
--- a/src/ev_kqueue.c
+++ b/src/ev_kqueue.c
@@ -51,8 +51,8 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	/* first, scan the update list to find changes */
 	for (updt_idx = 0; updt_idx < fd_nbupdt; updt_idx++) {
 		fd = fd_updt[updt_idx];
-		en = fdtab[fd].spec_e & 15;  /* new events */
-		eo = fdtab[fd].spec_e >> 4;  /* previous events */
+		en = fdtab[fd].state & 15;  /* new events */
+		eo = fdtab[fd].state >> 4;  /* previous events */
 
 		if (fdtab[fd].owner && (eo ^ en)) {
 			if ((eo ^ en) & FD_EV_POLLED_R) {
@@ -79,7 +79,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 				}
 			}
 
-			fdtab[fd].spec_e = (en << 4) + en;  /* save new events */
+			fdtab[fd].state = (en << 4) + en;  /* save new events */
 
 			if (!(en & FD_EV_ACTIVE_RW)) {
 				/* This fd doesn't use any active entry anymore, we can
@@ -139,11 +139,11 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 		fdtab[fd].ev &= FD_POLL_STICKY;
 
 		if (kev[count].filter ==  EVFILT_READ) {
-			if ((fdtab[fd].spec_e & FD_EV_STATUS_R))
+			if ((fdtab[fd].state & FD_EV_STATUS_R))
 				fdtab[fd].ev |= FD_POLL_IN;
 		}
 		else if (kev[count].filter ==  EVFILT_WRITE) {
-			if ((fdtab[fd].spec_e & FD_EV_STATUS_W))
+			if ((fdtab[fd].state & FD_EV_STATUS_W))
 				fdtab[fd].ev |= FD_POLL_OUT;
 		}
 
diff --git a/src/ev_poll.c b/src/ev_poll.c
index 537157f..8b3f595 100644
--- a/src/ev_poll.c
+++ b/src/ev_poll.c
@@ -70,8 +70,8 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	/* first, scan the update list to find changes */
 	for (updt_idx = 0; updt_idx < fd_nbupdt; updt_idx++) {
 		fd = fd_updt[updt_idx];
-		en = fdtab[fd].spec_e & 15;  /* new events */
-		eo = fdtab[fd].spec_e >> 4;  /* previous events */
+		en = fdtab[fd].state & 15;  /* new events */
+		eo = fdtab[fd].state >> 4;  /* previous events */
 
 		if (fdtab[fd].owner && (eo ^ en)) {
 			if ((eo ^ en) & FD_EV_POLLED_RW) {
@@ -87,7 +87,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 					hap_fd_set(fd, fd_evts[DIR_WR]);
 			}
 
-			fdtab[fd].spec_e = (en << 4) + en;  /* save new events */
+			fdtab[fd].state = (en << 4) + en;  /* save new events */
 
 			if (!(en & FD_EV_ACTIVE_RW)) {
 				/* This fd doesn't use any active entry anymore, we can
diff --git a/src/ev_select.c b/src/ev_select.c
index 946fbfd..300cffa 100644
--- a/src/ev_select.c
+++ b/src/ev_select.c
@@ -53,8 +53,8 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 	/* first, scan the update list to find changes */
 	for (updt_idx = 0; updt_idx < fd_nbupdt; updt_idx++) {
 		fd = fd_updt[updt_idx];
-		en = fdtab[fd].spec_e & 15;  /* new events */
-		eo = fdtab[fd].spec_e >> 4;  /* previous events */
+		en = fdtab[fd].state & 15;  /* new events */
+		eo = fdtab[fd].state >> 4;  /* previous events */
 
 		if (fdtab[fd].owner && (eo ^ en)) {
 			if ((eo ^ en) & FD_EV_POLLED_RW) {
@@ -70,7 +70,7 @@ REGPRM2 static void _do_poll(struct poller *p, int exp)
 					FD_SET(fd, fd_evts[DIR_WR]);
 			}
 
-			fdtab[fd].spec_e = (en << 4) + en;  /* save new events */
+			fdtab[fd].state = (en << 4) + en;  /* save new events */
 
 			if (!(en & FD_EV_ACTIVE_RW)) {
 				/* This fd doesn't use any active entry anymore, we can
diff --git a/src/fd.c b/src/fd.c
index 12f38f1..ad45f46 100644
--- a/src/fd.c
+++ b/src/fd.c
@@ -77,7 +77,7 @@
  * reference is always valid unless the FD if currently being polled and not
  * updated (in which case the reference points to index 0).
  *
- * We store the FD state in the 4 lower bits of fdtab[fd].spec_e, and save the
+ * We store the FD state in the 4 lower bits of fdtab[fd].state, and save the
  * previous state upon changes in the 4 higher bits, so that changes are easy
  * to spot.
  */
@@ -125,7 +125,7 @@ void fd_delete(int fd)
 		cur_poller.clo(fd);
 
 	release_spec_entry(fd);
-	fdtab[fd].spec_e &= ~(FD_EV_CURR_MASK | FD_EV_PREV_MASK);
+	fdtab[fd].state &= ~(FD_EV_CURR_MASK | FD_EV_PREV_MASK);
 
 	port_range_release_port(fdinfo[fd].port_range, fdinfo[fd].local_port);
 	fdinfo[fd].port_range = NULL;
@@ -148,7 +148,7 @@ void fd_process_spec_events()
 
 	for (spec_idx = 0; spec_idx < fd_nbspec; ) {
 		fd = fd_spec[spec_idx];
-		e = fdtab[fd].spec_e;
+		e = fdtab[fd].state;
 
 		/*
 		 * Process the speculative events.
-- 
1.8.3.2

