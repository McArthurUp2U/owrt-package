From 87eb1d699429fed94e36fa68ec038d4100483831 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Tue, 13 May 2014 18:51:40 +0200
Subject: [PATCH 12/14] MINOR: server: create srv_was_usable() from
 srv_is_usable() and use a pointer

We used to call srv_is_usable() with either the current state and weights
or the previous ones. This causes trouble for future changes, so let's first
split it in two variants :
  - srv_is_usable(srv) considers the current status
  - srv_was_usable(srv) considers the previous status
---
 include/proto/backend.h | 26 ++++++++++++++++++++++----
 include/proto/queue.h   |  2 +-
 src/backend.c           |  4 ++--
 src/lb_chash.c          | 16 ++++++++--------
 src/lb_fas.c            | 16 ++++++++--------
 src/lb_fwlc.c           | 16 ++++++++--------
 src/lb_fwrr.c           | 18 +++++++++---------
 src/lb_map.c            |  4 ++--
 src/queue.c             |  2 +-
 9 files changed, 61 insertions(+), 43 deletions(-)

diff --git a/include/proto/backend.h b/include/proto/backend.h
index 7af92e2..ac9e190 100644
--- a/include/proto/backend.h
+++ b/include/proto/backend.h
@@ -52,12 +52,30 @@ static void inline be_set_sess_last(struct proxy *be)
 	be->be_counters.last_sess = now.tv_sec;
 }
 
-/* This function returns non-zero if a server with the given weight and state
- * is usable for LB, otherwise zero.
+/* This function returns non-zero if the designated server is usable for LB
+ * according to its current weight and current state. Otherwise it returns 0.
  */
-static inline int srv_is_usable(int state, int weight)
+static inline int srv_is_usable(const struct server *srv)
 {
-	if (!weight)
+	int state = srv->state;
+
+	if (!srv->eweight)
+		return 0;
+	if (state & (SRV_GOINGDOWN | SRV_MAINTAIN))
+		return 0;
+	if (!(state & SRV_RUNNING))
+		return 0;
+	return 1;
+}
+
+/* This function returns non-zero if the designated server was usable for LB
+ * according to its current weight and previous state. Otherwise it returns 0.
+ */
+static inline int srv_was_usable(const struct server *srv)
+{
+	int state = srv->prev_state;
+
+	if (!srv->prev_eweight)
 		return 0;
 	if (state & (SRV_GOINGDOWN | SRV_MAINTAIN))
 		return 0;
diff --git a/include/proto/queue.h b/include/proto/queue.h
index fb73926..c3b7762 100644
--- a/include/proto/queue.h
+++ b/include/proto/queue.h
@@ -75,7 +75,7 @@ static inline int server_has_room(const struct server *s) {
  * for and if/else usage.
  */
 static inline int may_dequeue_tasks(const struct server *s, const struct proxy *p) {
-	return (s && (s->nbpend || (p->nbpend && srv_is_usable(s->state, s->eweight))) &&
+	return (s && (s->nbpend || (p->nbpend && srv_is_usable(s))) &&
 		(!s->maxconn || s->cur_sess < srv_dynamic_maxconn(s)));
 }
 
diff --git a/src/backend.c b/src/backend.c
index 0912fd4..e9043b4 100644
--- a/src/backend.c
+++ b/src/backend.c
@@ -97,7 +97,7 @@ void recount_servers(struct proxy *px)
 	px->lbprm.tot_wact = px->lbprm.tot_wbck = 0;
 	px->lbprm.fbck = NULL;
 	for (srv = px->srv; srv != NULL; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
+		if (!srv_is_usable(srv))
 			continue;
 
 		if (srv->state & SRV_BACKUP) {
@@ -547,7 +547,7 @@ int assign_server(struct session *s)
 	      (!s->be->max_ka_queue ||
 	       server_has_room(__objt_server(conn->target)) ||
 	       (__objt_server(conn->target)->nbpend + 1) < s->be->max_ka_queue))) &&
-	    srv_is_usable(__objt_server(conn->target)->state, __objt_server(conn->target)->eweight)) {
+	    srv_is_usable(__objt_server(conn->target))) {
 		/* This session was relying on a server in a previous request
 		 * and the proxy has "option prefer-current-server" set, so
 		 * let's try to reuse the same server.
diff --git a/src/lb_chash.c b/src/lb_chash.c
index fb10c72..3563cff 100644
--- a/src/lb_chash.c
+++ b/src/lb_chash.c
@@ -101,10 +101,10 @@ static void chash_set_server_status_down(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (srv_is_usable(srv->state, srv->eweight))
+	if (srv_is_usable(srv))
 		goto out_update_state;
 
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (!srv_was_usable(srv))
 		/* server was already down */
 		goto out_update_backend;
 
@@ -121,7 +121,7 @@ static void chash_set_server_status_down(struct server *srv)
 				srv2 = srv2->next;
 			} while (srv2 &&
 				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
+				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
 	} else {
@@ -152,10 +152,10 @@ static void chash_set_server_status_up(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (!srv_is_usable(srv->state, srv->eweight))
+	if (!srv_is_usable(srv))
 		goto out_update_state;
 
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (srv_was_usable(srv))
 		/* server was already up */
 		goto out_update_backend;
 
@@ -213,8 +213,8 @@ static void chash_update_server_weight(struct server *srv)
 	 * possibly a new tree for this server.
 	 */
 
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
+	old_state = srv_was_usable(srv);
+	new_state = srv_is_usable(srv);
 
 	if (!old_state && !new_state) {
 		srv_lb_commit_status(srv);
@@ -398,7 +398,7 @@ void chash_init_server_tree(struct proxy *p)
 			srv->lb_nodes[node].node.key = full_hash(srv->puid * SRV_EWGHT_RANGE + node);
 		}
 
-		if (srv_is_usable(srv->state, srv->eweight))
+		if (srv_is_usable(srv))
 			chash_queue_dequeue_srv(srv);
 	}
 }
diff --git a/src/lb_fas.c b/src/lb_fas.c
index b8b0569..7bd3d05 100644
--- a/src/lb_fas.c
+++ b/src/lb_fas.c
@@ -80,10 +80,10 @@ static void fas_set_server_status_down(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (srv_is_usable(srv->state, srv->eweight))
+	if (srv_is_usable(srv))
 		goto out_update_state;
 
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (!srv_was_usable(srv))
 		/* server was already down */
 		goto out_update_backend;
 
@@ -100,7 +100,7 @@ static void fas_set_server_status_down(struct server *srv)
 				srv2 = srv2->next;
 			} while (srv2 &&
 				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
+				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
 	} else {
@@ -132,10 +132,10 @@ static void fas_set_server_status_up(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (!srv_is_usable(srv->state, srv->eweight))
+	if (!srv_is_usable(srv))
 		goto out_update_state;
 
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (srv_was_usable(srv))
 		/* server was already up */
 		goto out_update_backend;
 
@@ -195,8 +195,8 @@ static void fas_update_server_weight(struct server *srv)
 	 * possibly a new tree for this server.
 	 */
 	 
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
+	old_state = srv_was_usable(srv);
+	new_state = srv_is_usable(srv);
 
 	if (!old_state && !new_state) {
 		srv_lb_commit_status(srv);
@@ -257,7 +257,7 @@ void fas_init_server_tree(struct proxy *p)
 
 	/* queue active and backup servers in two distinct groups */
 	for (srv = p->srv; srv; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
+		if (!srv_is_usable(srv))
 			continue;
 		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.fas.bck : &p->lbprm.fas.act;
 		fas_queue_srv(srv);
diff --git a/src/lb_fwlc.c b/src/lb_fwlc.c
index ca68a33..9fb57ac 100644
--- a/src/lb_fwlc.c
+++ b/src/lb_fwlc.c
@@ -72,10 +72,10 @@ static void fwlc_set_server_status_down(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (srv_is_usable(srv->state, srv->eweight))
+	if (srv_is_usable(srv))
 		goto out_update_state;
 
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (!srv_was_usable(srv))
 		/* server was already down */
 		goto out_update_backend;
 
@@ -92,7 +92,7 @@ static void fwlc_set_server_status_down(struct server *srv)
 				srv2 = srv2->next;
 			} while (srv2 &&
 				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
+				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
 	} else {
@@ -124,10 +124,10 @@ static void fwlc_set_server_status_up(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (!srv_is_usable(srv->state, srv->eweight))
+	if (!srv_is_usable(srv))
 		goto out_update_state;
 
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (srv_was_usable(srv))
 		/* server was already up */
 		goto out_update_backend;
 
@@ -187,8 +187,8 @@ static void fwlc_update_server_weight(struct server *srv)
 	 * possibly a new tree for this server.
 	 */
 	 
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
+	old_state = srv_was_usable(srv);
+	new_state = srv_is_usable(srv);
 
 	if (!old_state && !new_state) {
 		srv_lb_commit_status(srv);
@@ -249,7 +249,7 @@ void fwlc_init_server_tree(struct proxy *p)
 
 	/* queue active and backup servers in two distinct groups */
 	for (srv = p->srv; srv; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
+		if (!srv_is_usable(srv))
 			continue;
 		srv->lb_tree = (srv->state & SRV_BACKUP) ? &p->lbprm.fwlc.bck : &p->lbprm.fwlc.act;
 		fwlc_queue_srv(srv);
diff --git a/src/lb_fwrr.c b/src/lb_fwrr.c
index b8756b6..f15de23 100644
--- a/src/lb_fwrr.c
+++ b/src/lb_fwrr.c
@@ -42,10 +42,10 @@ static void fwrr_set_server_status_down(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (srv_is_usable(srv->state, srv->eweight))
+	if (srv_is_usable(srv))
 		goto out_update_state;
 
-	if (!srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (!srv_was_usable(srv))
 		/* server was already down */
 		goto out_update_backend;
 
@@ -65,7 +65,7 @@ static void fwrr_set_server_status_down(struct server *srv)
 				srv2 = srv2->next;
 			} while (srv2 &&
 				 !((srv2->state & SRV_BACKUP) &&
-				   srv_is_usable(srv2->state, srv2->eweight)));
+				   srv_is_usable(srv2)));
 			p->lbprm.fbck = srv2;
 		}
 	} else {
@@ -98,10 +98,10 @@ static void fwrr_set_server_status_up(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (!srv_is_usable(srv->state, srv->eweight))
+	if (!srv_is_usable(srv))
 		goto out_update_state;
 
-	if (srv_is_usable(srv->prev_state, srv->prev_eweight))
+	if (srv_was_usable(srv))
 		/* server was already up */
 		goto out_update_backend;
 
@@ -165,8 +165,8 @@ static void fwrr_update_server_weight(struct server *srv)
 	 * possibly a new tree for this server.
 	 */
 	 
-	old_state = srv_is_usable(srv->prev_state, srv->prev_eweight);
-	new_state = srv_is_usable(srv->state, srv->eweight);
+	old_state = srv_was_usable(srv);
+	new_state = srv_is_usable(srv);
 
 	if (!old_state && !new_state) {
 		srv_lb_commit_status(srv);
@@ -290,7 +290,7 @@ void fwrr_init_server_groups(struct proxy *p)
 
 	/* queue active and backup servers in two distinct groups */
 	for (srv = p->srv; srv; srv = srv->next) {
-		if (!srv_is_usable(srv->state, srv->eweight))
+		if (!srv_is_usable(srv))
 			continue;
 		fwrr_queue_by_weight((srv->state & SRV_BACKUP) ?
 				p->lbprm.fwrr.bck.init :
@@ -319,7 +319,7 @@ static void fwrr_queue_srv(struct server *s)
 	/* Delay everything which does not fit into the window and everything
 	 * which does not fit into the theorical new window.
 	 */
-	if (!srv_is_usable(s->state, s->eweight)) {
+	if (!srv_is_usable(s)) {
 		fwrr_remove_from_tree(s);
 	}
 	else if (s->eweight <= 0 ||
diff --git a/src/lb_map.c b/src/lb_map.c
index 2d296d7..a108bdb 100644
--- a/src/lb_map.c
+++ b/src/lb_map.c
@@ -31,7 +31,7 @@ static void map_set_server_status_down(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (srv_is_usable(srv->state, srv->eweight))
+	if (srv_is_usable(srv))
 		goto out_update_state;
 
 	/* FIXME: could be optimized since we know what changed */
@@ -50,7 +50,7 @@ static void map_set_server_status_up(struct server *srv)
 	if (!srv_lb_status_changed(srv))
 		return;
 
-	if (!srv_is_usable(srv->state, srv->eweight))
+	if (!srv_is_usable(srv))
 		goto out_update_state;
 
 	/* FIXME: could be optimized since we know what changed */
diff --git a/src/queue.c b/src/queue.c
index abc0f8c..006941b 100644
--- a/src/queue.c
+++ b/src/queue.c
@@ -109,7 +109,7 @@ struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px)
 	ps = pendconn_from_srv(srv);
 	pp = pendconn_from_px(px);
 	/* we want to get the definitive pendconn in <ps> */
-	if (!pp || !srv_is_usable(rsrv->state, rsrv->eweight)) {
+	if (!pp || !srv_is_usable(rsrv)) {
 		if (!ps)
 			return NULL;
 	} else {
-- 
1.8.3.2

