From 2a4b70fffdbe93a873a2248ecdea4e87a4bcab52 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Thu, 22 May 2014 18:42:35 +0200
Subject: [PATCH 43/54] MINOR: cli: introduce a new "set server" command

This command supports "agent", "health", "state" and "weight" to adjust
various server attributes as well as changing server health check statuses
on the fly or setting the drain mode.
---
 doc/configuration.txt | 24 +++++++++++++++++
 src/dumpstats.c       | 74 +++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 98 insertions(+)

diff --git a/doc/configuration.txt b/doc/configuration.txt
index b81b78d..2308c5c 100644
--- a/doc/configuration.txt
+++ b/doc/configuration.txt
@@ -13308,6 +13308,30 @@ set rate-limit ssl-sessions global <value>
   is passed in number of sessions per second sent to the SSL stack. It applies
   before the handshake in order to protect the stack against handshake abuses.
 
+set server <backend>/<server> agent [ up | down ]
+  Force a server's agent to a new state. This can be useful to immediately
+  switch a server's state regardless of some slow agent checks for example.
+  Note that the change is propagated to tracking servers if any.
+
+set server <backend>/<server> health [ up | stopping | down ]
+  Force a server's health to a new state. This can be useful to immediately
+  switch a server's state regardless of some slow health checks for example.
+  Note that the change is propagated to tracking servers if any.
+
+set server <backend>/<server> state [ ready | drain | maint ]
+  Force a server's administrative state to a new state. This can be useful to
+  disable load balancing and/or any traffic to a server. Setting the state to
+  "ready" puts the server in normal mode, and the command is the equivalent of
+  the "enable server" command. Setting the state to "maint" disables any traffic
+  to the server as well as any health checks. This is the equivalent of the
+  "disable server" command. Setting the mode to "drain" only removes the server
+  from load balancing but still allows it to be checked and to accept new
+  persistent connections. Changes are propagated to tracking servers if any.
+
+set server <backend>/<server> weight <weight>[%]
+  Change a server's weight to the value passed in argument. This is the exact
+  equivalent of the "set weight" command below.
+
 set table <table> key <key> [data.<data_type> <value>]*
   Create or update a stick-table entry in the table. If the key is not present,
   an entry is inserted. See stick-table in section 4.2 to find all possible
diff --git a/src/dumpstats.c b/src/dumpstats.c
index 4e4b657..21eff52 100644
--- a/src/dumpstats.c
+++ b/src/dumpstats.c
@@ -157,6 +157,7 @@ static const char stats_sock_usage_msg[] =
 	"  show table [id]: report table usage stats or dump this table's contents\n"
 	"  get weight     : report a server's current weight\n"
 	"  set weight     : change a server's weight\n"
+	"  set server     : change a server's state or weight\n"
 	"  set table [id] : update or create a table entry's data\n"
 	"  set timeout    : change a timeout setting\n"
 	"  set maxconn    : change a maxconn setting\n"
@@ -1375,6 +1376,79 @@ static int stats_sock_parse_request(struct stream_interface *si, char *line)
 			}
 			return 1;
 		}
+		else if (strcmp(args[1], "server") == 0) {
+			struct server *sv;
+			const char *warning;
+
+			sv = expect_server_admin(s, si, args[2]);
+			if (!sv)
+				return 1;
+
+			if (strcmp(args[3], "weight") == 0) {
+				warning = server_parse_weight_change_request(sv, args[4]);
+				if (warning) {
+					appctx->ctx.cli.msg = warning;
+					appctx->st0 = STAT_CLI_PRINT;
+				}
+			}
+			else if (strcmp(args[3], "state") == 0) {
+				if (strcmp(args[4], "ready") == 0)
+					srv_adm_set_ready(sv);
+				else if (strcmp(args[4], "drain") == 0)
+					srv_adm_set_drain(sv);
+				else if (strcmp(args[4], "maint") == 0)
+					srv_adm_set_maint(sv);
+				else {
+					appctx->ctx.cli.msg = "'set server <srv> state' expects 'ready', 'drain' and 'maint'.\n";
+					appctx->st0 = STAT_CLI_PRINT;
+				}
+			}
+			else if (strcmp(args[3], "health") == 0) {
+				if (sv->track) {
+					appctx->ctx.cli.msg = "cannot change health on a tracking server.\n";
+					appctx->st0 = STAT_CLI_PRINT;
+				}
+				else if (strcmp(args[4], "up") == 0) {
+					sv->check.health = sv->check.rise + sv->check.fall - 1;
+					srv_set_running(sv, "changed from CLI");
+				}
+				else if (strcmp(args[4], "stopping") == 0) {
+					sv->check.health = sv->check.rise + sv->check.fall - 1;
+					srv_set_stopping(sv, "changed from CLI");
+				}
+				else if (strcmp(args[4], "down") == 0) {
+					sv->check.health = 0;
+					srv_set_stopped(sv, "changed from CLI");
+				}
+				else {
+					appctx->ctx.cli.msg = "'set server <srv> health' expects 'up', 'stopping', or 'down'.\n";
+					appctx->st0 = STAT_CLI_PRINT;
+				}
+			}
+			else if (strcmp(args[3], "agent") == 0) {
+				if (!(sv->agent.state & CHK_ST_ENABLED)) {
+					appctx->ctx.cli.msg = "agent checks are not enabled on this server.\n";
+					appctx->st0 = STAT_CLI_PRINT;
+				}
+				else if (strcmp(args[4], "up") == 0) {
+					sv->agent.health = sv->agent.rise + sv->agent.fall - 1;
+					srv_set_running(sv, "changed from CLI");
+				}
+				else if (strcmp(args[4], "down") == 0) {
+					sv->agent.health = 0;
+					srv_set_stopped(sv, "changed from CLI");
+				}
+				else {
+					appctx->ctx.cli.msg = "'set server <srv> agent' expects 'up' or 'down'.\n";
+					appctx->st0 = STAT_CLI_PRINT;
+				}
+			}
+			else {
+				appctx->ctx.cli.msg = "'set server <srv>' only supports 'agent', 'health', 'state' and 'weight'.\n";
+				appctx->st0 = STAT_CLI_PRINT;
+			}
+			return 1;
+		}
 		else if (strcmp(args[1], "timeout") == 0) {
 			if (strcmp(args[2], "cli") == 0) {
 				unsigned timeout;
-- 
1.8.3.2

