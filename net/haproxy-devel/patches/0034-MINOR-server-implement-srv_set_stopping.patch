From 8eb7784634f30b2d2988716a7fa4395b31161a05 Mon Sep 17 00:00:00 2001
From: Willy Tarreau <w@1wt.eu>
Date: Wed, 21 May 2014 13:54:57 +0200
Subject: [PATCH 34/54] MINOR: server: implement srv_set_stopping()

This function was taken from check_set_server_drain(). It does not
consider health checks at all and only sets a server to stopping
provided it's not in maintenance and is not currently stopped. The
resulting state will be STOPPING. The state change is propagated
to tracked servers.

For now the function is not used, but the goal is to split health
checks status from server status and to be able to change a server's
state regardless of health checks statuses.
---
 include/proto/server.h | 10 ++++++++++
 src/server.c           | 45 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+)

diff --git a/include/proto/server.h b/include/proto/server.h
index 634aa2a..aae1bd7 100644
--- a/include/proto/server.h
+++ b/include/proto/server.h
@@ -146,6 +146,16 @@ void srv_set_stopped(struct server *s, const char *reason);
  */
 void srv_set_running(struct server *s, const char *reason);
 
+/* Marks server <s> stopping regardless of its checks' statuses and provided it
+ * isn't in maintenance. Notifies by all available means, recounts the remaining
+ * servers on the proxy and tries to grab requests from the proxy. It
+ * automatically recomputes the number of servers, but not the map. Maintenance
+ * servers are ignored. It reports <reason> if non-null as the reason for going
+ * up. Note that it makes use of the trash to build the log strings, so <reason>
+ * must not be placed there.
+ */
+void srv_set_stopping(struct server *s, const char *reason);
+
 /* Puts server <s> into maintenance mode, and propagate that status down to all
  * tracking servers. This does the same action as the CLI's "disable server x".
  * A log is emitted for all servers that were not yet in maintenance mode.
diff --git a/src/server.c b/src/server.c
index 42a80f1..98ac2cd 100644
--- a/src/server.c
+++ b/src/server.c
@@ -332,6 +332,51 @@ void srv_set_running(struct server *s, const char *reason)
 		srv_set_running(srv, NULL);
 }
 
+/* Marks server <s> stopping regardless of its checks' statuses and provided it
+ * isn't in maintenance. Notifies by all available means, recounts the remaining
+ * servers on the proxy and tries to grab requests from the proxy. It
+ * automatically recomputes the number of servers, but not the map. Maintenance
+ * servers are ignored. It reports <reason> if non-null as the reason for going
+ * up. Note that it makes use of the trash to build the log strings, so <reason>
+ * must not be placed there.
+ */
+void srv_set_stopping(struct server *s, const char *reason)
+{
+	struct server *srv;
+	int xferred;
+
+	if (s->admin & SRV_ADMF_MAINT)
+		return;
+
+	if (s->state == SRV_ST_STOPPING)
+		return;
+
+	s->last_change = now.tv_sec;
+	s->state = SRV_ST_STOPPING;
+	if (s->proxy->lbprm.set_server_status_down)
+		s->proxy->lbprm.set_server_status_down(s);
+
+	/* we might have sessions queued on this server and waiting for
+	 * a connection. Those which are redispatchable will be queued
+	 * to another server or to the proxy itself.
+	 */
+	xferred = pendconn_redistribute(s);
+
+	chunk_printf(&trash,
+	             "%sServer %s/%s is stopping", s->flags & SRV_F_BACKUP ? "Backup " : "",
+	             s->proxy->id, s->id);
+
+	srv_append_status(&trash, s, reason, xferred, 0);
+
+	Warning("%s.\n", trash.str);
+	send_log(s->proxy, LOG_NOTICE, "%s.\n", trash.str);
+
+	if (!s->proxy->srv_bck && !s->proxy->srv_act)
+		set_backend_down(s->proxy);
+
+	for (srv = s->trackers; srv; srv = srv->tracknext)
+		srv_set_stopping(srv, NULL);
+}
 
 /* Puts server <s> into maintenance mode, and propagate that status down to all
  * tracking servers. This does the same action as the CLI's "disable server x".
-- 
1.8.3.2

